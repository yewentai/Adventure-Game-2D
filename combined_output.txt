----- Start of game_over.h -----
#ifndef GAME_OVER_H
#define GAME_OVER_H

#include <QDialog>
#include <QPushButton>
#include <QLabel>
#include <QVBoxLayout>
#include <QDebug>

class GameOverDialog : public QDialog
{
    Q_OBJECT

public:
    explicit GameOverDialog(QWidget *parent = nullptr) : QDialog(parent)
    {
        setWindowTitle("Game Over");
        QVBoxLayout *layout = new QVBoxLayout(this);

        QLabel *label = new QLabel("Game Over!", this);
        label->setAlignment(Qt::AlignCenter);
        layout->addWidget(label);

        QPushButton *restartButton = new QPushButton("Restart", this);
        layout->addWidget(restartButton);

        connect(restartButton, &QPushButton::clicked, this, &GameOverDialog::onRestartClicked);
    }

    // signals:
    //     void restartGame();

private slots:
    void onRestartClicked()
    {
        this->close(); // Close the dialog
        qDebug() << "Dialog closed";
    }
};

#endif // GAME_OVER_H

----- End of game_over.h -----

----- Start of main.cpp -----
#include "mainwindow.h"
#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication app(argc, argv); // Create a QApplication object, which manages the application's control flow.
    MainWindow window;            // Create an instance of the MainWindow class, representing the main application window.
    window.show();                // Display the main window to the user.
    return app.exec();            // Start the event loop and execute the application, handling user interactions.
}

----- End of main.cpp -----

----- Start of mainwindow.cpp -----
#include "mainwindow.h"
#include <iostream>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{
    // Main window settings
    this->setWindowTitle("MainWindow");
    this->resize(837, 593);

    // Central widget
    QWidget *centralWidget = new QWidget(this);
    this->setCentralWidget(centralWidget);

    // Top-level horizontal layout
    QHBoxLayout *mainLayout = new QHBoxLayout(centralWidget);

    // Tab widget
    tabWidget = new QTabWidget();
    tabWidget->setGeometry(10, 10, 550, 571);
    tabWidget->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    tabWidget->setMinimumSize(550, 550);
    mainLayout->addWidget(tabWidget);

    // Tab pages
    tab2D = new QStackedWidget();
    tab2D->setWindowTitle("Graphic");
    tab2D->setGeometry(0, 0, 542, 542);
    tabWidget->addTab(tab2D, "Graphic");

    tabText = new QStackedWidget();
    tabText->setWindowTitle("Text");
    tabText->setGeometry(0, 0, 542, 542);
    tabWidget->addTab(tabText, "Text");

    // Layout for side widgets
    QVBoxLayout *sideLayout = new QVBoxLayout();
    mainLayout->addLayout(sideLayout);
    sideLayout->setSizeConstraint(QLayout::SetMinimumSize);

    // Health Label
    healthLabel = new QLabel("Health", centralWidget);
    healthLabel->setAlignment(Qt::AlignCenter);
    sideLayout->addWidget(healthLabel);

    // Health Progress Bar
    healthBar = new QProgressBar(centralWidget);
    healthBar->setValue(24);
    sideLayout->addWidget(healthBar);

    // Energy Label
    energyLabel = new QLabel("Energy", centralWidget);
    energyLabel->setAlignment(Qt::AlignCenter);
    sideLayout->addWidget(energyLabel);

    // Energy Progress Bar
    energyBar = new QProgressBar(centralWidget);
    energyBar->setValue(24);
    sideLayout->addWidget(energyBar);

    // Difficulty Label
    difficultyLabel = new QLabel("Difficulty", centralWidget);
    difficultyLabel->setAlignment(Qt::AlignCenter);
    sideLayout->addWidget(difficultyLabel);

    // Difficulty Slider
    difficultySlider = new MySlider(centralWidget);
    difficultySlider->setOrientation(Qt::Horizontal);
    difficultySlider->setMinimum(1);
    difficultySlider->setMaximum(10);
    difficultySlider->setValue(5);
    sideLayout->addWidget(difficultySlider);

    // Auto Play Button
    autoplayBtn = new QPushButton("auto play", centralWidget);
    sideLayout->addWidget(autoplayBtn);

    // Restart Button
    QPushButton *restartBtn = new QPushButton("restart", centralWidget);
    sideLayout->addWidget(restartBtn);
    connect(restartBtn, SIGNAL(clicked()), this, SLOT(onRestartButtonClicked()));

    // Command Label
    commandLabel = new QLabel("Command", centralWidget);
    commandLabel->setVisible(false);
    sideLayout->addWidget(commandLabel);

    // Command Examples Text Browser
    commandExamplesBrowser = new QTextBrowser(centralWidget);
    commandExamplesBrowser->setPlainText("Examples:\n"
                                         "1. up\n"
                                         "2. down\n"
                                         "3. left\n"
                                         "4. right\n"
                                         "5. goto 2,2\n"
                                         "6. attack\n"
                                         "7. heal\n"
                                         );
    // Set the Browser's size to fit the text
    commandExamplesBrowser->setFixedSize(90, 155);

    // Set the background to be transparent
    QPalette palette = commandExamplesBrowser->palette();
    palette.setBrush(QPalette::Base, Qt::transparent);
    commandExamplesBrowser->setPalette(palette);

    commandExamplesBrowser->setVisible(false);
    sideLayout->addWidget(commandExamplesBrowser);

    // Command Text Edit
    commandTextEdit = new MyTextEditor(centralWidget);

    // Setup command widget (initially hidden)
    commandTextEdit->setVisible(false);
    sideLayout->addWidget(commandTextEdit);

    // connect onTabChanged slot to corresponding signal
    connect(tabWidget, SIGNAL(currentChanged(int)), this, SLOT(onTabChanged(int)));

    // Ensure the sideLayout stretches to fill the space
    sideLayout->addStretch();

    // Initialize the game world
    worldInit();
}

MainWindow::~MainWindow()
{
    levelModel.reset();
    view2D.reset();
    viewText.reset();
    pController.reset();
    pEnemyControllers.clear();
}

void MainWindow::worldInit()
{
    // For restart, check if the model and views are deleted
    if (levelModel)
        levelModel.reset();
    if (view2D)
        view2D.reset();
    if (viewText)
        viewText.reset();
    if (pController)
        pController.reset();
    if (!pEnemyControllers.empty())
        pEnemyControllers.clear();

    // reset difficulty slider
    difficultySlider->setValue(5);

    //    if (!gameOverDialog)                   gameOverDialog.reset();

    // Create a levelModel that contains and manages the gameModels
    levelModel.reset(new LevelController());
    const std::unique_ptr<GameModel> &gameModel = levelModel->getCurrentModel();
    connect(levelModel.get(), SIGNAL(levelUpdated(int)), this, SLOT(onLevelChanged(int)));

    // Create a ProtagonistModel object with some parameters.
    const std::unique_ptr<ProtagonistModel> &protag = gameModel->getProtagonist();

    // Calculate the size of the tiles based on the height of the gView2D widget.
    int size = tab2D->size().height() / gameModel->getCols();

    // Adjust the widget size if it's smaller than the number of columns.
    if (tab2D->size().height() <= gameModel->getCols())
    {
        size = 1;
        tab2D->setFixedSize(gameModel->getCols(), gameModel->getRows());
    }

    // Create a View2D object using the GameModel and tile size.
    if (view2D)
    {
        tab2D->removeWidget(view2D.get());
    }
    view2D.reset(new View2D(gameModel.get(), size));

    // Add a 2D view tab to the tabWidget.
    tab2D->addWidget(view2D.get());

    // Set the background for the View2D using the gameModel's background image.
    QPixmap bgScaled = gameModel->getBackground()
                           ->scaled(gameModel->getCols() * view2D->getTileSize(),
                                    gameModel->getRows() * view2D->getTileSize());
    auto bg = view2D->getScene()->addPixmap(bgScaled);
    view2D->setBackgroundBrush(QBrush(bg->pixmap()));
    if (viewText)
    {
        tabText->removeWidget(viewText.get());
    }
    // Create a ViewText object using the GameModel and tile size.
    viewText.reset(new ViewText(gameModel.get(), size));

    // Add a text view tab to the tabWidget.
    tabText->addWidget(viewText.get());

    // Set the health and energy bars based on the protagonist's values.
    healthBar->setValue(protag->getHealth());
    qDebug() << healthBar->value();
    energyBar->setValue(protag->getEnergy());
    qDebug() << energyBar->value();

    // Connect signals from the protagonist to update the health and energy bars.
    connect(protag.get(), SIGNAL(healthChanged(int)), healthBar, SLOT(setValue(int)));
    connect(protag.get(), SIGNAL(energyChanged(int)), energyBar, SLOT(setValue(int)));

    // Connect the commandEntered signal from the view to the handleCommandEntered slot.
    pController.reset(new ProtagonistController(gameModel.get(), protag));

    connect(view2D.get(), SIGNAL(keyPressed(int)), pController.get(), SLOT(handleKeyPress(int)));
    connect(commandTextEdit, SIGNAL(enterKeyPressed(QString)), pController.get(), SLOT(handleCommand(QString)));
    connect(autoplayBtn, &QPushButton::clicked, pController.get(), &ProtagonistController::autoPlay);
    connect(view2D.get(), &View2D::tileClicked, pController.get(), &ProtagonistController::handleTileClick);
    // connect the slider to the protagController
    connect(difficultySlider, SIGNAL(sliderDragged(int)), pController.get(), SLOT(updateDifficulty(int)));

    // marking the path
    connect(pController.get(), &ProtagonistController::tileVisited, view2D.get(), &View2D::markVisited);
    connect(pController.get(), &ProtagonistController::tileVisited, viewText.get(), &ViewText::markVisited);
    connect(pController.get(), &ProtagonistController::tileCleaned, view2D.get(), &View2D::cleanupMarkedTiles);
    connect(pController.get(), &ProtagonistController::tileCleaned, viewText.get(), &ViewText::cleanupMarkedTiles);
    // game over logic
    connect(pController.get(), &ProtagonistController::protagDead, this, &MainWindow::checkGameOver);
    connect(pController.get(), &ProtagonistController::protagTired, this, &MainWindow::checkGameOver);

    connect(commandTextEdit, SIGNAL(tabKeyPressed(QString)), pController.get(), SLOT(handleTab(QString)));
    connect(pController.get(), SIGNAL(commandToComplete(QString)), commandTextEdit, SLOT(setCompletedCommand(QString)));

    // Connect the PEnemy model view and controller
    for (const auto &enemy : gameModel->getEnemies())
    {
        if (dynamic_cast<PEnemyModel *>(enemy.get()))
        {
            pEnemyControllers.emplace_back(new PEnemyController(dynamic_cast<PEnemyModel *>(enemy.get())));
        }
        if (dynamic_cast<XEnemy *>(enemy.get()))
        {
            connect(dynamic_cast<XEnemy *>(enemy.get()), SIGNAL(bounce()), pController.get(), SLOT(handleBounce()));
        }
    }
    this->update();
    view2D->setFocus();
    qDebug() << "World initialized and updated!";
}

void MainWindow::onTabChanged(int index)
{
    // Assuming the "Text" tab is the second tab (index 1)
    currentTab = index;
    bool isTextTabSelected = (index == 1);
    commandLabel->setVisible(isTextTabSelected);
    commandExamplesBrowser->setVisible(isTextTabSelected);
    commandTextEdit->setVisible(isTextTabSelected);
}

void MainWindow::onRestartButtonClicked()
{
    // gameOverScreen->setVisible(false);
    gameOver = false;
    worldInit();
}

void MainWindow::onLevelChanged(int preIndex)
{
    qDebug() << "LevelChanged, world updating...";
    const std::unique_ptr<GameModel> &currModel = levelModel->getCurrentModel();

    // Calculate the size of the tiles based on the height of the gView2D widget.
    int size = tab2D->size().height() / currModel->getCols();

    // Adjust the widget size if it's smaller than the number of columns.
    if (tab2D->size().height() <= currModel->getCols())
    {
        size = 1;
        tab2D->setFixedSize(currModel->getCols(), currModel->getRows());
    }

    // Create a View2D object using the GameModel and tile size.
    if (view2D)
    {
        tab2D->removeWidget(view2D.get());
    }
    view2D.reset(new View2D(currModel.get(), size));

    // Add a 2D view tab to the tabWidget.
    tab2D->addWidget(view2D.get());

    if (viewText)
    {
        tabText->removeWidget(viewText.get());
    }
    // Create a ViewText object using the GameModel and tile size.
    viewText.reset(new ViewText(currModel.get(), size));

    // Add a text view tab to the tabWidget.
    tabText->addWidget(viewText.get());

    // Set the health and energy bars based on the protagonist's values.
    healthBar->setValue(currModel->getProtagonist()->getHealth());
    qDebug() << healthBar->value();
    energyBar->setValue(currModel->getProtagonist()->getEnergy());
    qDebug() << energyBar->value();

    // Connect signals from the protagonist to update the health and energy bars.
    connect(currModel->getProtagonist().get(), SIGNAL(healthChanged(int)), healthBar, SLOT(setValue(int)));
    connect(currModel->getProtagonist().get(), SIGNAL(energyChanged(int)), energyBar, SLOT(setValue(int)));

    // Connect the commandEntered signal from the view to the handleCommandEntered slot.
    // Create a ProtagonistModel object with some parameters.
    const std::unique_ptr<ProtagonistModel> &protag = currModel->getProtagonist();

    pController.reset(new ProtagonistController(currModel.get(), protag));
    connect(view2D.get(), SIGNAL(keyPressed(int)), pController.get(), SLOT(handleKeyPress(int)));
    connect(commandTextEdit, SIGNAL(enterKeyPressed(QString)), pController.get(), SLOT(handleCommand(QString)));
    bool success_auto = connect(autoplayBtn, &QPushButton::clicked, pController.get(), &ProtagonistController::autoPlay);

    qDebug() << success_auto;
    if (!success_auto)
    {
        qDebug() << "Autplay connection failed";
    }
    else
        qDebug() << "Autoplay connection successful";
    bool success = connect(view2D.get(), &View2D::tileClicked, pController.get(), &ProtagonistController::handleTileClick);
    if (!success)
    {
        qDebug() << "Click move connection failed";
    }
    else
        qDebug() << "Click move connection successful";

    // marking the path
    connect(pController.get(), &ProtagonistController::tileVisited, view2D.get(), &View2D::markVisited);
    connect(pController.get(), &ProtagonistController::tileVisited, viewText.get(), &ViewText::markVisited);

    // game over logic
    connect(pController.get(), &ProtagonistController::protagDead, this, &MainWindow::checkGameOver);
    connect(pController.get(), &ProtagonistController::protagTired, this, &MainWindow::checkGameOver);

    connect(commandTextEdit, SIGNAL(tabKeyPressed(QString)), pController.get(), SLOT(handleTab(QString)));
    connect(pController.get(), SIGNAL(commandToComplete(QString)), commandTextEdit, SLOT(setCompletedCommand(QString)));

    // Connect the PEnemy model view and controller
    pEnemyControllers.clear();
    for (const auto &enemy : currModel->getEnemies())
    {
        if (dynamic_cast<PEnemyModel *>(enemy.get()))
        {
            pEnemyControllers.emplace_back(new PEnemyController(dynamic_cast<PEnemyModel *>(enemy.get())));
        }
    }
    this->update();
    view2D->setFocus();
    qDebug() << "World updated based on level!";
}

void MainWindow::checkGameOver()
{
    if (!gameOver)
    {
        gameOver = true;
        gameOverDialog = new GameOverDialog();
        gameOverDialog->setVisible(true);
        gameOverDialog->raise(); // Bring the dialog to the front
        gameOverDialog->activateWindow();
        connect(gameOverDialog, SIGNAL(restartGame()), this, SLOT(onRestartButtonClicked()));
    }
}

----- End of mainwindow.cpp -----

----- Start of mainwindow.h -----
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
// Components
#include <QMenu>
#include <QMenuBar>
#include <QProgressBar>
#include <QAction>
#include <QLineEdit>
#include <QLabel>
#include <QPushButton>
#include <QSlider>
#include <QTabWidget>
#include <QTextBrowser>
// Layout
#include <QStackedWidget>
#include <QFormLayout>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QGraphicsView>
#include <QPlainTextEdit>
#include <memory> // Include this for smart pointers
#include "lib/world.h"
#include "views/text.h"
#include "views/graphic.h"
#include "models/game.h"
#include "controllers/protagonist_control.h"
#include "controllers/penemy_control.h"
#include "controllers/level_control.h"
#include "my_text_editor.h"
#include "my_slider.h"
#include "views/game_over.h"

QT_BEGIN_NAMESPACE
namespace Ui
{
    class MainWindow;
}
QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    // Constructor for the MainWindow class
    MainWindow(QWidget *parent = nullptr);

    // Destructor for the MainWindow class
    ~MainWindow();

    // Initialize the game world and user interface
    void worldInit();

    // Update the game world
    void updateGameState();

    // Handle the command entered by the user
    void handleCommandEntered();

protected:
    // bool eventFilter(QObject *obj, QEvent *event);

signals:
    void commandEntered(const QString &command);

protected:
    // bool eventFilter(QObject *obj, QEvent *event);

public slots:
    void onTabChanged(int index);
    void onRestartButtonClicked();
    void onLevelChanged(int preIndex);
    void checkGameOver();

private:
    int currentTab;
    Ui::MainWindow *ui;                   // User interface components
    QHBoxLayout *hboxLayout1;             // Horizontal layout for UI components
    QGridLayout *worldLayout;             // Grid layout for the game world
    QPushButton *btn;                     // Button for UI interaction
    QLabel *commandLabel;                 // Command Label
    QLabel *difficultyLabel;              // Difficulty Label
    QTextBrowser *commandExamplesBrowser; // Command examples browser
    MyTextEditor *commandTextEdit;        // Declare the command widget as a member variable
    QTabWidget *tabWidget;                // Widget for different views
    QStackedWidget *tab2D;                // Widget for Graphic view
    QStackedWidget *tabText;              // Widget for Text view
    QProgressBar *healthBar;
    QProgressBar *energyBar;
    // std::unique_ptr<GameModel> gameModel;
    std::unique_ptr<LevelController> levelModel = nullptr;
    MySlider *difficultySlider;
    std::unique_ptr<GameModel> gameModel = nullptr;
    std::unique_ptr<View2D> view2D = nullptr;
    std::unique_ptr<ViewText> viewText = nullptr;
    std::unique_ptr<ProtagonistController> pController = nullptr;
    QPushButton *autoplayBtn;
    std::vector<std::unique_ptr<PEnemyController>> pEnemyControllers;
    GameOverDialog *gameOverDialog;
    // QWidget* gameOverScreen;
    QLabel *healthLabel;
    QLabel *energyLabel;
    bool gameOver{false};
    bool levelInit{false};
};

#endif // MAINWINDOW_H

----- End of mainwindow.h -----

----- Start of my_slider.h -----
#ifndef MY_SLIDER_H
#define MY_SLIDER_H

#include <QSlider>
#include <QDebug>

class MySlider : public QSlider
{
    Q_OBJECT

signals:
    void sliderDragged(int);

public:
    MySlider(QWidget *parent = nullptr)
        : QSlider(parent)
    {
    }

protected:
    void mouseMoveEvent(QMouseEvent *event) override
    {
        QSlider::mouseMoveEvent(event);
        emit sliderDragged(this->value());
    }
};

#endif // MY_SLIDER_H

----- End of my_slider.h -----

----- Start of my_text_editor.cpp -----
#include "my_text_editor.h"
#include <QKeyEvent>
#include <QDebug>

void MyTextEditor::setCompletedCommand(const QString &command)
{
    this->setPlainText(command);
    this->moveCursor(QTextCursor::End); // Move cursor to end of text
}

----- End of my_text_editor.cpp -----

----- Start of my_text_editor.h -----
#ifndef MY_TEXT_EDITOR_H
#define MY_TEXT_EDITOR_H

#include <QApplication>
#include <QPlainTextEdit>
#include <QKeyEvent>
#include <QObject>
#include <QDebug>

class MyTextEditor : public QPlainTextEdit
{
    Q_OBJECT

signals:
    void enterKeyPressed(QString);
    void tabKeyPressed(QString);

public slots:
    void setCompletedCommand(const QString &command);

public:
    MyTextEditor(QWidget *parent = nullptr)
        : QPlainTextEdit(parent)
    {
    }

protected:
    void keyPressEvent(QKeyEvent *event) override
    {
        if (event->key() == Qt::Key_Tab)
        {
            emit tabKeyPressed(this->toPlainText());
        }
        else if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return)
        {
            emit enterKeyPressed(this->toPlainText());
            this->clear();
        }
        else
        {
            QPlainTextEdit::keyPressEvent(event);
        }
    }
};

#endif // MY_TEXT_EDITOR_H

----- End of my_text_editor.h -----

----- Start of level_control.cpp -----
#include "level_control.h"
#include <QDebug>

LevelController::LevelController()
    : currentLevel{1}, MAXLEVEL{3}, currentIndex{1}
{
    // Initialize the levels array
    levels[0] = nullptr;
    levels[1] = std::make_unique<GameModel>(QString(":/src/world_images/worldmap.png"), 5, 10, 0.25f, 50.0f);
    levels[2] = std::make_unique<GameModel>(QString(":/src/world_images/worldmap1.png"), 10, 8, 0.25f, 50.0f);

    // Connect models to gates
    connectModel();
}

int LevelController::getCurrentLevel() const
{
    return currentLevel;
}

void LevelController::connectModel()
{
    for (auto &model : levels)
    {
        if (model)
        {
            for (auto &g : model->getGates())
            {
                if (g->getType()) // If it's a "next" gate
                {
                    qDebug() << "LevelUp connected to gate";
                    connect(g.get(), SIGNAL(levelUp()), this, SLOT(handleLevelUp()));
                }
                else
                {
                    // Connect the levelDown signal to the handleLevelDown slot
                    connect(g.get(), SIGNAL(levelDown()), this, SLOT(handleLevelDown()));
                }
            }
        }
    }
}

const std::unique_ptr<GameModel> &LevelController::getCurrentModel()
{
    return levels.at(currentIndex);
}

const std::unique_ptr<GameModel> &LevelController::getModelByIndex(int index)
{
    return levels.at(index);
}

int LevelController::getCurrentIndex() const
{
    return currentIndex;
}

void LevelController::handleLevelUp()
{
    if ((currentLevel < MAXLEVEL) && (currentLevel >= 1))
    {
        qDebug() << "Handling LevelUp";
        // Increase the level
        currentLevel++;
        // Update the current Index
        currentIndex = currentLevel % 3;
        // put the new model to the nextIndex
        int nextIndex = (currentLevel + 1) % 3;
        int preIndex = (currentLevel - 1) % 3;
        switch (currentLevel)
        {
        case 2:
            // Strategy for level 2
            levels[nextIndex] = std::make_unique<GameModel>(QString(":/src/world_images/worldmap1.png"), 10, 8, 0.25f, 50.0f);
            connectModel();
            qDebug() << "Current level:" << currentLevel;
            qDebug() << "Current Index:" << currentIndex;
            qDebug() << "Next Index:" << nextIndex;
            qDebug() << "Level 2 strategy selected.";
            emit levelUpdated(preIndex);
            break;
        case 3:
            // Strategy for level 3 (maximum level, no next level)
            // if (levels[nextIndex] != nullptr)
            // {
            //     levels[nextIndex] = nullptr;
            // }
            levels[nextIndex] = std::make_unique<GameModel>(QString(":/src/world_images/worldmap2.png"), 10, 8, 0.25f, 50.0f);
            connectModel();
            emit levelUpdated(preIndex);
            qDebug() << "Level 3 strategy selected.";
            break;
        default:
            // Default strategy for unknown levels
            qDebug() << "Unknown levels strategy selected.";
            break;
        }
    }
}

void LevelController::handleLevelDown()
{
    qDebug() << "Handling LevelDown";
    if ((currentLevel <= MAXLEVEL) && (currentLevel > 1))
    {
        // Decrease the level
        currentLevel--;
        // Update the current Index
        currentIndex = currentLevel % 3;
        int nextIndex = (currentLevel - 1) % 3;
        int preIndex = (currentLevel + 1) % 3;
        switch (currentLevel)
        {
        case 1:
            // Strategy for level 1 (minimum level, no previous level)
            if (levels[nextIndex] != nullptr)
            {
                levels[nextIndex] = nullptr;
            }
            emit levelUpdated(preIndex);
            qDebug() << "Level 1 strategy selected.";
            break;
        case 2:
            // Strategy for level 2
            levels[nextIndex] = std::make_unique<GameModel>(QString(":/src/world_images/worldmap1.png"), 5, 10, 0.25f, 50.0f);
            connectModel();
            emit levelUpdated(preIndex);
            qDebug() << "Level 2 strategy selected.";
            break;
        default:
            // Default strategy for unknown levels
            qDebug() << "Unknown levels strategy selected.";
            break;
        }
    }
}

----- End of level_control.cpp -----

----- Start of level_control.h -----
#ifndef LEVELCONTROLLER_H
#define LEVELCONTROLLER_H

#include <QObject>
#include "models/game.h"
class LevelController : public QObject
{
    Q_OBJECT
public:
    LevelController();

    int getCurrentLevel() const;
    void connectModel();
    const std::unique_ptr<GameModel> &getCurrentModel();
    const std::unique_ptr<GameModel> &getModelByIndex(int index);
    int getCurrentIndex() const;

private:
    std::array<std::unique_ptr<GameModel>, 3> levels;
    int currentIndex;
    int currentLevel;
    const int MAXLEVEL;
public slots:
    void handleLevelUp();
    void handleLevelDown();
signals:
    void levelUpdated(int preIndex);
};

#endif // LEVELCONTROLLER_H

----- End of level_control.h -----

----- Start of penemy_control.cpp -----
#include "penemy_control.h"

PEnemyController::PEnemyController(PEnemyModel *pEnemy) : pEnemyModel(pEnemy)
{
    connect(pEnemyModel, SIGNAL(dead()), this, SLOT(handleDead()));
    connect(this, SIGNAL(startPoison()), pEnemyModel, SLOT(poison()));
    connect(pEnemyModel, SIGNAL(poisonLevelUpdated(int)), this, SLOT(handlePoisonLevelUpdated(int)));
}

void PEnemyController::handleDead()
{
    if (pEnemyModel->getPoisonLevel() > 0.0f)
    {
        emit startPoison();
    }
    else
    {
        pEnemyModel->setPoisonRange(0); // no poison after dead
    }
}

void PEnemyController::handlePoisonLevelUpdated(int value)
{
    pEnemyModel->addPoisonRange(1);
}

----- End of penemy_control.cpp -----

----- Start of penemy_control.h -----
#ifndef PENEMY_CONTROL_H
#define PENEMY_CONTROL_H

#include <QObject>
#include "models/game.h"

class PEnemyController : public QObject
{
    Q_OBJECT
public:
    PEnemyController(PEnemyModel *pEnemy);

private:
    PEnemyModel *pEnemyModel;

public slots:
    void handleDead();
    void handlePoisonLevelUpdated(int value);

signals:
    void startPoison();
};

#endif // PENEMY_CONTROL_H

----- End of penemy_control.h -----

----- Start of protagonist_control.cpp -----
#include "protagonist_control.h"
#include <iostream>
#include <cmath>
#include <QTimer>

// Constructor for ProtagonistController class
ProtagonistController::ProtagonistController(GameModel *model, const std::unique_ptr<ProtagonistModel> &protag)
    : protagModel(protag), gameModel(model)
{
    // Map commands to functions
    commandHandlers = {
        {"up", [this]()
         { moveUp(); }},
        {"down", [this]()
         { moveDown(); }},
        {"left", [this]()
         { moveLeft(); }},
        {"right", [this]()
         { moveRight(); }},
        {"goto ", [this]()
         { goTo(protagModel->getXPos(), protagModel->getYPos()); }
        },
        {"attack", [this]()
         { attackNearest(); }},
        {"heal", [this]()
         { healNearest(); }},
        // Add other command handlers here...
    };
    healthDecreaseTimer = new QTimer(this);
    movementTimer = new QTimer(this);
}

// Function to handle a fight with an enemy
void ProtagonistController::fight(std::unique_ptr<Enemy> &enemy)
{
    if (enemy->getDefeated())
        return;
    float remainHP = protagModel->getHealth() - difficulty_factor * enemy->getValue();
    float remainEP = protagModel->getEnergy() + (1 + difficulty_factor) * enemy->getValue();
    updateHP(remainHP);
    updateEP(remainEP);
    enemy->setDefeated(true);
    qDebug() << "Enemy killed";
}

void ProtagonistController::updateDifficulty(int difficulty)
{
    difficulty_factor = difficulty * 0.1;
    qDebug() << "Difficulty factor: " << difficulty_factor;
}

/********************************************************************************
Basic functions
*********************************************************************************/

// Function to heal the protagonist using a health pack
void ProtagonistController::heal(std::unique_ptr<HealthPack> &hp)
{
    float remainHP = protagModel->getHealth() + (1 + difficulty_factor) * hp->getHP();
    updateHP(remainHP);
    hp->setHP(0.0f);
}

// Function to poison the protagonist
void ProtagonistController::poisoned(float poisonLevel)
{
    if (!protagModel->getIsPoisoned())
    {
        protagModel->setIsPoisoned(true);

        // Poison duration and timer setup

        elapsed = 0; // Time elapsed

        // Calculate the amount of poison to apply each second
        poisonPerInterval = poisonLevel / 30.0;

        connect(healthDecreaseTimer, SIGNAL(timeout()), this, SLOT(handlePoisoned()));

        healthDecreaseTimer->start(timerInterval);
    }
}

// Function to update the protagonist's health
void ProtagonistController::updateHP(float remainHP)
{
    if (remainHP <= 0.0f)
    {
        protagModel->setHealth(0.0f);
        emit protagDead();
    }
    else if (remainHP >= 100.0f)
    {
        protagModel->setHealth(100.0f);
    }
    else
    {
        protagModel->setHealth(remainHP);
    }
}

// Function to update the protagonist's energy
void ProtagonistController::updateEP(float remainEP)
{
    if (remainEP <= 0.0f)
    {
        protagModel->setEnergy(0.0f);
        emit protagTired();
        emit protagDead();
    }
    else if (remainEP >= 100.0f)
    {
        protagModel->setEnergy(100.0f);
    }
    else
    {
        protagModel->setEnergy(remainEP);
    }
}

// Function to move the protagonist right
int ProtagonistController::moveRight()
{
    int x = protagModel->getXPos();
    int y = protagModel->getYPos();
    int row = gameModel->getRows();

    // Check if the right move is possible
    if (!gameModel->isWall(x + 1, y) && (x + 1) < row)
    {
        // Move right
        protagModel->setPos(x + 1, y);
        updateProtagonistState(x + 1, y);
        return 1;
    }
    else
    {
        return 0; // Return 0 if the move is not possible
    }
}

// Function to move the protagonist left
int ProtagonistController::moveLeft()
{
    int x = protagModel->getXPos();
    int y = protagModel->getYPos();

    // Check if the left move is possible
    if (!gameModel->isWall(x - 1, y) && (x - 1) >= 0)
    {
        // Move left
        protagModel->setPos(x - 1, y);
        updateProtagonistState(x - 1, y);
        return 1; // Return 1 if the move is successful
    }
    else
    {
        return 0; // Return 0 if the move is not possible
    }
}

// Function to move the protagonist up
int ProtagonistController::moveUp()
{
    int x = protagModel->getXPos();
    int y = protagModel->getYPos();

    // Check if the up move is possible
    if (!gameModel->isWall(x, y - 1) && (y - 1) >= 0)
    {
        // Move up
        protagModel->setPos(x, y - 1);
        updateProtagonistState(x, y - 1);
        return 1; // Return 1 if the move is successful
    }
    else
    {
        return 0; // Return 0 if the move is not possible
    }
}

// Function to move the protagonist down
int ProtagonistController::moveDown()
{
    int x = protagModel->getXPos();
    int y = protagModel->getYPos();
    int col = gameModel->getCols();

    // Check if the down move is possible
    if (!gameModel->isWall(x, y + 1) && (y + 1) < col)
    {
        // Move down
        protagModel->setPos(x, y + 1);
        updateProtagonistState(x, y + 1);
        return 1; // Return 1 if the move is successful
    }
    else
    {
        return 0; // Return 0 if the move is not possible
    }
}

// Function to update the protagonist's state based on the tile
void ProtagonistController::updateProtagonistState(int x, int y)
{
    if (nextLevel)
    {
        return; // Skip updates if transitioning to the next level
    }

    // Safely access elements in gameModel
    auto it_T = gameModel->findTile(x, y);
    if (it_T != gameModel->getTiles().end())
    {
        float remainEP = protagModel->getEnergy() - difficulty_factor * ((1.0f - it_T->get()->getValue()) * 3.0f);
        updateEP(remainEP);
    }

    auto it_E = gameModel->findEnemy(x, y);
    if (it_E != gameModel->getEnemies().end())
    {
        XEnemy *xEnemy = dynamic_cast<XEnemy *>(it_E->get());
        if (xEnemy)
        {
            xEnemy->bounceProtagonist();
        }
        fight(*it_E);
    }

    auto it_H = gameModel->findHealthPack(x, y);
    if (it_H != gameModel->getHealthPacks().end())
    {
        heal(*it_H);
    }

    float poisonLevel = gameModel->findPoison(x, y);
    if (poisonLevel > 0.0f)
    {
        poisoned(poisonLevel);
    }

    auto it_G = gameModel->findGate(x, y);
    if (it_G != gameModel->getGates().end())
    {
        stopAutoPlay();
        stopClickMove();
        nextLevel = true;
        qDebug() << "Next level in update: " << nextLevel;
        it_G->get()->updateLevel();
    }
}

// Function to handle the protagonist being poisoned
void ProtagonistController::handlePoisoned()
{
    if (elapsed <= totalTime)
    {
        elapsed += timerInterval;
        updateHP(protagModel->getHealth() - poisonPerInterval);
    }
    else
    {
        healthDecreaseTimer->stop();
        protagModel->setIsPoisoned(false);
    }
}

void ProtagonistController::attackNearest(){
    Tile *en_nearest;
    float minDistance = std::numeric_limits<float>::max();
        for (const auto& enemy : gameModel->getEnemies()) {
            if (!enemy->getDefeated()) {
                int dx = protagModel->getXPos() - enemy->getXPos();
                int dy = protagModel->getYPos() - enemy->getYPos();
                float distance = std::sqrt(dx * dx + dy * dy);
                if (distance < minDistance) {
                    minDistance = distance;
                    en_nearest = enemy.get();
                }
            }
        }
        goTo(en_nearest->getXPos(),en_nearest->getYPos());

}
void ProtagonistController::healNearest(){
        Tile *hp_nearest;
        float minDistance = std::numeric_limits<float>::max();
        for (const auto& hp : gameModel->getHealthPacks()) {
            if (hp->getHP() > 0) {
                int dx = protagModel->getXPos() - hp->getXPos();
                int dy = protagModel->getYPos() - hp->getYPos();
                float distance = std::sqrt(dx * dx + dy * dy);
                if (distance < minDistance) {
                    minDistance = distance;
                    hp_nearest = hp.get();
                }
            }
        }
        qDebug() << hp_nearest->getXPos() << hp_nearest->getYPos();
        goTo(hp_nearest->getXPos(),hp_nearest->getYPos());
}

// Function to move the protagonist to a specified position
void ProtagonistController::goTo(int x_target, int y_target)
{
    stopAutoPlay();
    stopClickMove();

    // Check if the target position is valid
    if (x_target < 0 || x_target >= gameModel->getRows() || y_target < 0 || y_target >= gameModel->getCols() || gameModel->isWall(x_target, y_target))
    {
        qDebug() << "Invalid target position or blocked by a wall.";
        return;
    }

    // Calculate the path using a simple heuristic, e.g., Manhattan distance
    std::vector<int> path;

    int currentX = protagModel->getXPos();
    int currentY = protagModel->getYPos();

    while (currentX != x_target || currentY != y_target)
    {
        int dx = x_target - currentX;
        int dy = y_target - currentY;

        if (std::abs(dx) > std::abs(dy))
        {
            if (dx > 0)
            {
                path.push_back(6); // Move right
                currentX++;
            }
            else
            {
                path.push_back(2); // Move left
                currentX--;
            }
        }
        else
        {
            if (dy > 0)
            {
                path.push_back(4); // Move down
                currentY++;
            }
            else
            {
                path.push_back(0); // Move up
                currentY--;
            }
        }
    }

    if (!path.empty())
    {
        this->path = path; // Assign the calculated path to the member variable
        currentIndex = 0;
        connect(movementTimer, &QTimer::timeout, this, &ProtagonistController::moveNextStep);
        movementTimer->start(250); // Adjust as needed
        isClickMove = true;
        // Emit signal to mark the tile as visited
        emit tileVisited(x_target, y_target);
    }
    else
    {
        qDebug() << "No path found for goTo";
    }
}

Tile *ProtagonistController::findNearestObjective()
{
    Tile *nearestObjective = nullptr;
    float minDistance = std::numeric_limits<float>::max();
    int protagonistX = protagModel->getXPos();
    int protagonistY = protagModel->getYPos();

    bool prioritizeHealthPack = protagModel->getHealth() < 50.0f;
    bool enemiesAllDefeated = std::all_of(gameModel->getEnemies().begin(), gameModel->getEnemies().end(),
                                          [](const auto &enemy)
                                          { return enemy->getDefeated(); });

    auto updateNearest = [&](const auto &obj)
    {
        int objX = obj->getXPos();
        int objY = obj->getYPos();
        float distance = std::hypot(objX - protagonistX, objY - protagonistY);
        if (distance < minDistance)
        {
            minDistance = distance;
            nearestObjective = obj.get();
        }
    };

    if (prioritizeHealthPack)
    {
        for (const auto &hp : gameModel->getHealthPacks())
        {
            if (hp->getHP() > 0)
            {
                updateNearest(hp);
            }
        }
    }

    if (!nearestObjective && !enemiesAllDefeated)
    {
        for (const auto &enemy : gameModel->getEnemies())
        {
            if (!enemy->getDefeated())
            {
                updateNearest(enemy);
            }
        }
    }

    if (!nearestObjective || enemiesAllDefeated)
    {
        for (const auto &gate : gameModel->getGates())
        {
            if (gate->getType() == 1)
                updateNearest(gate);
        }
    }

    return nearestObjective;
}

void ProtagonistController::handleStep(int step)
{
    if (!isProtagonistActive())
    {
        qDebug() << "Protagonist is not active";
        return;
    }
    // 0: up, 1: up-left, 2: left, 3: down-left, 4: down, 5: down-right, 6: right, 7: up-right
    qDebug() << "Step: " << step;
    switch (step)
    {
    case 0:
        moveUp();
        break;
    case 1:
        moveUp();
        moveLeft();
        break;
    case 2:
        moveLeft();
        break;
    case 3:
        moveDown();
        moveLeft();
        break;
    case 4:
        moveDown();
        break;
    case 5:
        moveDown();
        moveRight();
        break;
    case 6:
        moveRight();
        break;
    case 7:
        moveUp();
        moveRight();
        break;
    default:
        qDebug() << "Invalid step: " << step;
        break;
    }
}

void ProtagonistController::clickMove()
{
    stopAutoPlay();

    // Check if the clicked tile coordinates are valid
    if (clickedTileCoords.first < 0 || clickedTileCoords.second < 0)
    {
        qDebug() << "Invalid clicked tile coordinates";
        return;
    }

    const auto &tiles = gameModel->getTiles();
    Tile *startTile = dynamic_cast<Tile *>(protagModel.get());

    std::vector<TileAdapter> tileAdapters;
    tileAdapters.reserve(tiles.size());
    for (auto &tile : tiles)
    {
        tileAdapters.emplace_back(tile.get());
    }

    auto it = std::find_if(tiles.begin(), tiles.end(), [this](const auto &tile)
                           { return tile->getXPos() == clickedTileCoords.first && tile->getYPos() == clickedTileCoords.second; });

    if (it == tiles.end())
    {
        qDebug() << "Clicked tile not found in tile list";
        return;
    }

    Tile *destinationTile = it->get();

    Comparator<TileAdapter> comparator = [](const TileAdapter &a, const TileAdapter b)
    {
        return a.h > b.h;
    };

    // Create the PathFinder instance
    PathFinder<TileAdapter, Tile> pathFinder(
        tileAdapters, startTile, destinationTile, comparator,
        gameModel->getRows(), 1.0f);

    // Calculate the path
    std::vector<int> path = pathFinder.A_star();

    if (!path.empty())
    {
        this->path = path; // Assign the calculated path to the member variable
        currentIndex = 0;
        connect(movementTimer, &QTimer::timeout, this, &ProtagonistController::moveNextStep);
        movementTimer->start(250); // Adjust as needed
        isClickMove = true;
    }
    else
    {
        qDebug() << "No path found for clickMove";
    }
}

void ProtagonistController::handleTileClick(int x, int y)
{
    if (isAutoPlaying)
    {
        stopAutoPlay();
    }
    setClickedTile(x, y);
    clickMove();
}

void ProtagonistController::stopAutoPlay()
{
    if (isAutoPlaying)
    {
        movementTimer->stop();
        disconnect(movementTimer, nullptr, this, nullptr);
        currentIndex = 0;
        isAutoPlaying = false;
    }
}

void ProtagonistController::stopClickMove()
{
    if (isClickMove)
    {
        movementTimer->stop();
        disconnect(movementTimer, nullptr, this, nullptr);
        currentIndex = 0;
        isClickMove = false;
    }
}

void ProtagonistController::autoPlay()
{
    stopClickMove();

    const auto &tiles = gameModel->getTiles();
    if (!isProtagonistActive())
    {
        qDebug() << "Protagonist is not active";
        return;
    }

    // Create TileAdapters for each Tile
    std::vector<TileAdapter> tileAdapters;
    tileAdapters.reserve(tiles.size());
    for (auto &tile : tiles)
    {
        tileAdapters.emplace_back(tile.get());
    }

    Tile *startTile = dynamic_cast<Tile *>(protagModel.get());
    Tile *destinationTile = findNearestObjective();

    if (!destinationTile)
    {
        qDebug() << "No destination objective found";
        return;
    }

    Comparator<TileAdapter> comparator = [](const TileAdapter &a, const TileAdapter b)
    {
        return a.h > b.h;
    };

    // Create the PathFinder instance
    PathFinder<TileAdapter, Tile> pathFinder(
        tileAdapters, startTile, destinationTile, comparator,
        gameModel->getRows(), 1.0f);

    // Calculate the path
    std::vector<int> path = pathFinder.A_star();

    if (!path.empty())
    {
        this->path = path; // Assign the calculated path to the member variable
        currentIndex = 0;
        connect(movementTimer, &QTimer::timeout, this, &ProtagonistController::moveNextStep);
        movementTimer->start(250); // Adjust as needed
        isAutoPlaying = true;
    }
    else
    {
        qDebug() << "No path found for autoPlay";
    }
}

void ProtagonistController::moveNextStep()
{
    if (currentIndex < path.size())
    {
        handleStep(path[currentIndex]);
        qDebug() << "Next level in moveNextStep: " << nextLevel;

        if (nextLevel == false || nextLevel == 0)
        {
            updateProtagonistState(protagModel->getXPos(), protagModel->getYPos());
            emit tileVisited(protagModel->getXPos(), protagModel->getYPos());
            markedCoordinates.push_back(std::make_pair(protagModel->getXPos(), protagModel->getYPos()));
        }
        currentIndex++;
        // Emit signal to mark the tile as visited
    }
    else
    {
        movementTimer->stop();
        disconnect(movementTimer, nullptr, this, nullptr);
        currentIndex = 0;

        if (isAutoPlaying)
        {
            Tile *newDestination = findNearestObjective();
            if (newDestination)
            {
                autoPlay(); // Restart autoPlay with new objective
            }
            else
            {
                isAutoPlaying = false;
            }
        }
        else if (isClickMove)
        {
            isClickMove = false;
            qDebug() << "click move completed";
            for (auto &p : markedCoordinates)
                emit tileCleaned(p);
        }
    }
}

void ProtagonistController::handleBounce()
{
    int direction = rand() % 4;
    int moveSuccess = 0;
    switch (direction)
    {
    case 0:
        moveUp();
        moveSuccess = moveUp();
        break;
    case 1:
        moveDown();
        moveSuccess = moveDown();
        break;
    case 2:
        moveLeft();
        moveSuccess = moveLeft();
        break;
    case 3:
        moveRight();
        moveSuccess = moveRight();
        break;
    default:
        qDebug() << "Invalid direction: " << direction;
        break;
    }
    if (moveSuccess == 0)
    {
        handleBounce();
    }
    else if (moveSuccess == 1)
    {
        qDebug() << "Moved to position" << protagModel->getXPos() << "," << protagModel->getYPos();
    }
}


/********************************************************************************
Handle typed commands or key presses
*********************************************************************************/
// Function to handle tab key presses
void ProtagonistController::handleTab(QString partialCommand)
{
    QStringList matchingCommands;

    for (const QString &command : commandHandlers.keys())
    {
        if (command.startsWith(partialCommand.trimmed(), Qt::CaseInsensitive))
        {
            matchingCommands.append(command);
        }
    }

    // If there is exactly one matching command, emit a signal to complete the command
    if (matchingCommands.count() == 1)
    {
        emit commandToComplete(matchingCommands.first());
    }
}

// Function to handle typed commands
void ProtagonistController::handleCommand(QString command)
{
    if (!isProtagonistActive())
    {
        qDebug() << "Protagonist is not active";
        return;
    }
    command = command.toLower();

    // Check for "goto x,y" pattern
    if (command.startsWith("goto "))
    {
        QStringList parts = command.mid(4).split(",");
        if (parts.size() == 2)
        {
            bool ok1, ok2;
            int x = parts[0].toInt(&ok1);
            int y = parts[1].toInt(&ok2);
            if (ok1 && ok2)
            {
                goTo(x, y);
                return;
            }
        }
    }

    // Execute the command if it exists in the commandHandlers map
    if (commandHandlers.contains(command))
    {
        commandHandlers[command]();
    }
    else
    {
        qDebug() << "Unknown command:" << command;
    }
}

// Function to handle key presses
void ProtagonistController::handleKeyPress(int key)
{
    if (!isProtagonistActive())
    {
        qDebug() << "Protagonist is not active";
        return;
    }
    QMap<int, std::function<void()>> keyHandlers = {
        {Qt::Key_Left, [this]()
         { moveLeft(); }},
        {Qt::Key_Right, [this]()
         { moveRight(); }},
        {Qt::Key_Up, [this]()
         { moveUp(); }},
        {Qt::Key_Down, [this]()
         { moveDown(); }}};

    // Check if the key is in the keyHandlers map and execute the corresponding movement function
    if (keyHandlers.contains(key))
        keyHandlers[key]();

    else
        qDebug() << "Unknown key pressed:" << key;
}

----- End of protagonist_control.cpp -----

----- Start of protagonist_control.h -----
#ifndef PROTAGONIST_CONTROL_H
#define PROTAGONIST_CONTROL_H

#include <QObject>
#include <QDebug>
#include <QEventLoop>
#include <QTimer>

#include "models/game.h"
#include "models/tileadapter.h"
#include "lib/pathfinder_class.h"
#include "lib/pathfinder_function.h"

class ProtagonistController : public QObject
{
    Q_OBJECT
public:
    ProtagonistController(GameModel *model, const std::unique_ptr<ProtagonistModel> &protag);
    int moveRight();
    int moveLeft();
    int moveUp();
    int moveDown();
    void goTo(int x, int y);
    void attackNearest();
    void healNearest();
    void handleStep(int step);
    void updateProtagonistState(int x, int y);
    Tile *findNearestObjective();
    void setClickedTile(int x, int y)
    {
        clickedTileCoords = std::make_pair(x, y);
    }

private:
    bool isAutoPlaying{false};
    bool isClickMove{false};
    bool autoPlayInterrupted = false;
    bool clickMoveActive{false};
    std::pair<int, int> clickedTileCoords{-1, -1};
    QTimer *movementTimer;
    QTimer *clickMoveTimer;

    void fight(std::unique_ptr<Enemy> &enemy);
    void heal(std::unique_ptr<HealthPack> &hp);
    void poisoned(float poisonLevel);
    void updateEP(float remainEP);
    void updateHP(float remainHP);
    bool isProtagonistActive()
    {

        if (protagModel->getHealth() > 0 && protagModel->getEnergy() > 0)
            return true;
        else
        {
            emit protagDead();
            return false;
        }
    };

    const std::unique_ptr<ProtagonistModel> &protagModel;
    GameModel *gameModel;
    QTimer *healthDecreaseTimer;
    int elapsed{0};                // Time elapsed
    const int totalTime{5000};     // Total time for poison effect
    const int timerInterval{1000}; // Interval for timer ticks (1 second)
    float poisonPerInterval{0.0f};
    QMap<QString, std::function<void()>> commandHandlers;
    unsigned long currentIndex{0};
    bool nextLevel{false};
    float difficulty_factor{0.5f};
    std::vector<int> path;
    //    std::vector<int,int> markedCoordinates;
    std::vector<std::pair<int, int>> markedCoordinates;
signals:
    void protagDead();
    void protagTired();
    void tileVisited(int x, int y);
    void tileCleaned(std::pair<int, int> coord);
    void commandToComplete(const QString &command);

public slots:
    void handleKeyPress(int key);
    void handleCommand(QString command);
    void autoPlay();
    void clickMove();
    void handleTab(QString command);
    void handlePoisoned();
    void handleBounce();
    void updateDifficulty(int value);
    void handleTileClick(int x, int y);
    void stopAutoPlay();
    void stopClickMove();
    void moveNextStep();
};

#endif // PROTAGONIST_CONTROL_H

----- End of protagonist_control.h -----

----- Start of xenemy_control.cpp -----
#include "xenemy_control.h"

XEnemyController::XEnemyController(XEnemyModel *xEnemy)
{
    xEnemyModel = xEnemy;
    connect(xEnemyModel, SIGNAL(dead()), this, SLOT(handleDead()));
}
----- End of xenemy_control.cpp -----

----- Start of xenemy_control.h -----
#ifndef XENEMY_CONTROL_H
#define XENEMY_CONTROL_H

#include <QObject>
#include "models/game.h"

class XEnemyController : public QObject
{
    Q_OBJECT
public:
    XEnemyController(XEnemyModel *xEnemy);

private:
    XEnemyModel *xEnemyModel;

public slots:
    void handleDead();

signals:
};

----- End of xenemy_control.h -----

----- Start of pathfinder.h -----
#ifndef PATHFINDER_H
#define PATHFINDER_H
#include <vector>
#include <functional>
#include <queue>
#include <iostream>
#include <limits>
#include <cmath>
#include <memory>
#include "qloggingcategory.h"

/*
 * A_star has 2 template parameters, T and U
 * T is the Node object which needs to have the fields as defined by the concept validNodeType
 *    3 floats: f, g and h to store the cost parameters of the A* algorithm
 *    a boolean visited which is set when you have already been to this node (~ closed list)
 *    a pointer to a Node: prev: the nodefrom which you got to this position
 *    Node should derive from Tile, so you can call getValue()
 * U is a position, passed a pointer, something which derives from Tile (or a Tile)
 * The comparator is used by the priority_queue to put the element with the lowest total cost in front
 * since Nodes is a 1D vector representing a 2D grid, we need know the width of this grid
 * heurWeight is the heuristic weight paramters defined by the A* algorithm
 *
 * The function returns a list of moves (0 to 7) using following encoding. The central point is your current position
 *
 *         7 0 1
 *         6   2
 *         5 4 3
 */

inline QLoggingCategory pathfinderCategory("pathfinder", QtDebugMsg);

template <typename T>
using Comparator = std::function<bool(const T&, const T&)>;

template <typename T>
using pq = std::priority_queue<T, std::vector<T>, Comparator<T>>;

template<typename U>
concept validPosType = requires(U * u)
{
  {u->getXPos()} -> std::same_as<int>;
  {u->getYPos()} -> std::same_as<int>;
};

template<typename T>
concept validNodeType = validPosType<T> && requires(T t)
{
  {T::f} -> std::same_as<float&>;
  {T::g} -> std::same_as<float&>;
  {T::h} -> std::same_as<float&>;
  {T::visited} -> std::same_as<bool&>;
  {T::prev} -> std::same_as<T*&>;
  {t.getValue()} -> std::same_as<float>;
};

template <validNodeType T, validPosType U>
std::vector<int> A_star(std::vector<T> & Nodes, const U * start, const U * destination, Comparator<T>& comp, unsigned int width, float heurWeight)
{
  pq<T> openList(comp);
  std::vector<int> path;
  T currentPathNode = Nodes.at(start->getYPos()*width+start->getXPos());
  T * parent = &(Nodes.at(start->getYPos()*width+start->getXPos()));
  Nodes.at(start->getYPos()*width+start->getXPos()).visited = true; // avoid to come here again
  while (currentPathNode.getXPos() != destination->getXPos()
         || currentPathNode.getYPos() != destination->getYPos())
  {
    int currentX = currentPathNode.getXPos();
    int currentY = currentPathNode.getYPos();
    qCDebug(pathfinderCategory) << "Node to continue... " << currentY << ", " << currentX;
    for (int deltaY = -1; deltaY <= 1; deltaY++)
      for (int deltaX = -1; deltaX <= 1; deltaX++){
        qCDebug(pathfinderCategory)<< "Checking : " << deltaX << ", " << deltaY;
        if (!(deltaX == 0 && deltaY == 0)){
          qCDebug(pathfinderCategory) << "Checking neighbour : " << deltaX << ", " << deltaY;
          checkNeighbour(Nodes, width, currentX+deltaX, currentY+deltaY, destination, parent, openList, heurWeight);
        }
      }
    if (openList.empty())
    {
      return std::vector<int>();
    }
    else
    {
      currentPathNode = openList.top();
      qCDebug(pathfinderCategory) << "currentPathNode from openlist: " << currentPathNode.getXPos() << ", " << currentPathNode.getYPos() << ", f: " << currentPathNode.h;
      qCDebug(pathfinderCategory) << "Node on top of openlist: " << openList.top().h;
      qCDebug(pathfinderCategory) << "Size of openlist: " << openList.size();
      parent = &(Nodes.at(currentPathNode.getYPos()*width+currentPathNode.getXPos()));
      openList.pop();
    }
  }
  //return list of path to reach destination
  T * dest = parent;
  //std::cout << "Getting list of moves to take." <<std::endl;
  while (dest->prev != nullptr)
  {
    int deltaX = dest->prev->getXPos() - dest->getXPos();
    int deltaY = dest->prev->getYPos() - dest->getYPos();
    int newMove = deltaX+10*deltaY;
    qCDebug(pathfinderCategory) << "X:" << deltaX << ", Y:" << deltaY;
    switch (newMove)
    {
      case -10: path.push_back(4); break;
      case -11: path.push_back(5); break;
      case -1: path.push_back(6); break;
      case 9: path.push_back(7); break;
      case 10: path.push_back(0); break;
      case 11: path.push_back(1); break;
      case 1: path.push_back(2); break;
      case -9: path.push_back(3); break;
      default: std::cerr << "wrong value for deltaX" << deltaX;
    }
    dest = dest->prev;
  }
  std::reverse(path.begin(), path.end());
  return path;
}


template <validNodeType T, typename U>
void checkNeighbour(std::vector<T> & Nodes, int width, int nX, int nY,  const U *destination, T* parent, pq<T> &openList, float heurWeight)
{
  int height = Nodes.size() / width;
  unsigned int currentX = parent->getXPos();
  unsigned int currentY = parent->getYPos();
  float currentCost = parent->f;
  if (nX >= 0 && nX < width && nY >= 0 && nY < height && (nX != 0 || nY != 0))
  {
    if (Nodes.at(nY*width+nX).getValue()!=std::numeric_limits<float>::infinity() ) //top
    {
      int manhDist = abs(static_cast<int>(destination->getXPos())-nX) + abs(static_cast<int>(destination->getYPos())-nY);
      float f = (std::fabs(Nodes.at(currentY*width+currentX).getValue() -
                           Nodes.at(nY*width+nX).getValue())) + 1.0f;
      qCDebug(pathfinderCategory) << "Manhattan distance from " << Nodes.at(currentY*width+currentX).getValue() << "x"
                                  <<   Nodes.at(nY*width+nX).getValue() << ";" << currentX << "x" << currentY << ";"
                                  << destination->getXPos() << "," << destination->getYPos() <<" to " << nX << "," << nY << " is " << manhDist
                                  << ", f is " << f;
      T & nextNode = Nodes.at(nY*width+nX);
      if (nextNode.visited == false)
      {
        //never been here
        //get distance to target
        nextNode.f = currentCost + f;
        nextNode.h = currentCost + f + heurWeight * manhDist;
        nextNode.prev = parent;
        nextNode.visited = true;
        qCDebug(pathfinderCategory)<< "Pushing in openlist... " << nX << ", " << nY << " currentCost:" << nextNode.h;
        openList.push(nextNode);
      }
      else
      {
        //check if current path is better than previous
        qCDebug(pathfinderCategory) << "Check if this path is better, currentCost:" << currentCost << ", f:" << f << ", nextnode.f:" << nextNode.f;
        if (currentCost + f + heurWeight * manhDist < (nextNode.h - 0.1f))
        {
          qCDebug(pathfinderCategory) << "This path is better, reparenting.";
          nextNode.f = currentCost + f;
          nextNode.h = currentCost + f + heurWeight * manhDist;
          nextNode.prev = parent;
          openList.push(nextNode);
        }
      }
    }
  }
  else
    qCDebug(pathfinderCategory) << "Not processing: " << nX << ", " << nY;
}
#endif // PATHFINDER_H

----- End of pathfinder.h -----

----- Start of pathfinder_class.h -----
#ifndef PATHFINDER_H
#define PATHFINDER_H
#include <vector>
#include <functional>
#include <queue>
#include <iostream>
#include <limits>
#include <cmath>
#include <memory>
#include <qloggingcategory.h>

/*
 * A_star has 2 template parameters, T and U
 * T is the Node object which needs to have the fields as defined by the concept validNodeType
 *    3 floats: f, g and h to store the cost parameters of the A* algorithm
 *    a boolean visited which is set when you have already been to this node (~ closed list)
 *    a pointer to a Node: prev: the nodefrom which you got to this position
 *    Node should derive from Tile, so you can call getValue()
 * U is a position, passed a pointer, something which derives from Tile (or a Tile)
 * The comparator is used by the priority_queue to put the element with the lowest total cost in front
 * since Nodes is a 1D vector representing a 2D grid, we need know the width of this grid
 * heurWeight is the heuristic weight paramters defined by the A* algorithm
 *
 * The function returns a list of moves (0 to 7) using following encoding. The central point is your current position
 *
 *         7 0 1
 *         6   2
 *         5 4 3
 */

template <typename T>
using Comparator = std::function<bool(const T&, const T&)>;

template <typename T>
using pq = std::priority_queue<T, std::vector<T>, Comparator<T>>;

template<typename U>
concept validPosType = requires(U * u)

{
  {u->getXPos()} -> std::same_as<int>;
  {u->getYPos()} -> std::same_as<int>;
};

template<typename T>
concept validNodeType = validPosType<T> && requires(T t)
{
  {T::f} -> std::same_as<float&>;
  {T::g} -> std::same_as<float&>;
  {T::h} -> std::same_as<float&>;
  {T::visited} -> std::same_as<bool&>;
  {T::prev} -> std::same_as<T*&>;
  {t.getValue()} -> std::same_as<float>;
};

template <validNodeType T, validPosType U>
class PathFinder
{
private:
  std::vector<T> & Nodes;
  const U * start;
  const U* destination;
  Comparator<T> & comp;
  unsigned int width;
  float heurWeight;
  QLoggingCategory pathfinderCategory{"pathfinder", QtCriticalMsg};

public:
  PathFinder(std::vector<T> & N, const U * s, const U * d, Comparator<T>& c, unsigned int w, float hW) :
      Nodes{N}, start{s}, destination{d}, comp{c}, width{w}, heurWeight{hW}
      {

      };

  const U *getStart() const {return start;};
  void setStart(const U *newStart) {start = newStart;};

  const U *getDestination() const {return destination;};
  void setDestination(const U *newDestination) {destination = newDestination;};

  float getHeurWeight() const {return heurWeight;};
  void setHeurWeight(float newHeurWeight) {heurWeight = newHeurWeight;};

  std::vector<T> &getNodes() const {return Nodes;};
  void setNodes(const std::vector<T> &newNodes) {Nodes = newNodes;};

  std::vector<int> A_star()
  {
    pq<T> openList(comp);
    std::vector<int> path;
    T currentPathNode = Nodes.at(start->getYPos()*width+start->getXPos());
    T * parent = &(Nodes.at(start->getYPos()*width+start->getXPos()));
    Nodes.at(start->getYPos()*width+start->getXPos()).visited = true; // avoid to come here again
    while (currentPathNode.getXPos() != destination->getXPos()
           || currentPathNode.getYPos() != destination->getYPos())
    {
      int currentX = currentPathNode.getXPos();
      int currentY = currentPathNode.getYPos();
      qCDebug(pathfinderCategory) << "Node to continue... " << currentY << ", " << currentX;
      for (int deltaY = -1; deltaY <= 1; deltaY++)
        for (int deltaX = -1; deltaX <= 1; deltaX++){
          qCDebug(pathfinderCategory)<< "Checking : " << deltaX << ", " << deltaY;
          if (!(deltaX == 0 && deltaY == 0)){
            qCDebug(pathfinderCategory) << "Checking neighbour : " << deltaX << ", " << deltaY;
            checkNeighbour(Nodes, width, currentX+deltaX, currentY+deltaY, destination, parent, openList, heurWeight);
          }
        }
      if (openList.empty())
      {
        return std::vector<int>();
      }
      else
      {
        currentPathNode = openList.top();
        qCDebug(pathfinderCategory) << "currentPathNode from openlist: " << currentPathNode.getXPos() << ", " << currentPathNode.getYPos() << ", f: " << currentPathNode.h;
        qCDebug(pathfinderCategory) << "Node on top of openlist: " << openList.top().h;
        qCDebug(pathfinderCategory) << "Size of openlist: " << openList.size();
        parent = &(Nodes.at(currentPathNode.getYPos()*width+currentPathNode.getXPos()));
        openList.pop();
      }
    }
    //return list of path to reach destination
    T * dest = parent;
    //std::cout << "Getting list of moves to take." <<std::endl;
    while (dest->prev != nullptr)
    {
      int deltaX = dest->prev->getXPos() - dest->getXPos();
      int deltaY = dest->prev->getYPos() - dest->getYPos();
      int newMove = deltaX+10*deltaY;
      qCDebug(pathfinderCategory) << "X:" << deltaX << ", Y:" << deltaY;
      switch (newMove)
      {
        case -10: path.push_back(4); break;
        case -11: path.push_back(5); break;
        case -1: path.push_back(6); break;
        case 9: path.push_back(7); break;
        case 10: path.push_back(0); break;
        case 11: path.push_back(1); break;
        case 1: path.push_back(2); break;
        case -9: path.push_back(3); break;
        default: std::cerr << "wrong value for deltaX" << deltaX;
      }
      dest = dest->prev;
    }
    std::reverse(path.begin(), path.end());
    return path;
  }


private:
  void checkNeighbour(std::vector<T> & Nodes, int width, int nX, int nY,  const U *destination, T* parent, pq<T> &openList, float heurWeight)
  {
    int height = Nodes.size() / width;
    unsigned int currentX = parent->getXPos();
    unsigned int currentY = parent->getYPos();
    float currentCost = parent->f;
    if (nX >= 0 && nX < width && nY >= 0 && nY < height && (nX != 0 || nY != 0))
    {
      if (Nodes.at(nY*width+nX).getValue()!=std::numeric_limits<float>::infinity() ) //top
      {
        int manhDist = abs(static_cast<int>(destination->getXPos())-nX) + abs(static_cast<int>(destination->getYPos())-nY);
        float f = (std::fabs(Nodes.at(currentY*width+currentX).getValue() -
                             Nodes.at(nY*width+nX).getValue())) + 0.01f;
        qCDebug(pathfinderCategory) << "Manhattan distance from " << Nodes.at(currentY*width+currentX).getValue() << "x"
                                    <<   Nodes.at(nY*width+nX).getValue() << ";" << currentX << "x" << currentY << ";"
                                    << destination->getXPos() << "," << destination->getYPos() <<" to " << nX << "," << nY << " is " << manhDist
                                    << ", f is " << f;
        T & nextNode = Nodes.at(nY*width+nX);
        if (nextNode.visited == false)
        {
          //never been here
          //get distance to target
          nextNode.f = currentCost + f;
          nextNode.h = currentCost + f + heurWeight * manhDist;
          nextNode.prev = parent;
          nextNode.visited = true;
          qCDebug(pathfinderCategory)<< "Pushing in openlist... " << nX << ", " << nY << " currentCost:" << nextNode.h;
          openList.push(nextNode);
        }
        else
        {
          //check if current path is better than previous
          qCDebug(pathfinderCategory) << "Check if this path is better, currentCost:" << currentCost << ", f:" << f << ", nextnode.f:" << nextNode.f;
          if (currentCost + f + heurWeight * manhDist < (nextNode.h - 0.1f))
          {
            qCDebug(pathfinderCategory) << "This path is better, reparenting.";
            nextNode.f = currentCost + f;
            nextNode.h = currentCost + f + heurWeight * manhDist;
            nextNode.prev = parent;
            openList.push(nextNode);
          }
        }
      }
    }
    else
      qCDebug(pathfinderCategory) << "Not processing: " << nX << ", " << nY;
  }
};


#endif // PATHFINDER_H

----- End of pathfinder_class.h -----

----- Start of pathfinder_function.h -----
#ifndef PATHFINDER_H
#define PATHFINDER_H
#include <vector>
#include <functional>
#include <queue>
#include <iostream>
#include <limits>
#include <cmath>
#include <memory>
#include "qloggingcategory.h"

/*
 * A_star has 2 template parameters, T and U
 * T is the Node object which needs to have the fields as defined by the concept validNodeType
 *    3 floats: f, g and h to store the cost parameters of the A* algorithm
 *    a boolean visited which is set when you have already been to this node (~ closed list)
 *    a pointer to a Node: prev: the nodefrom which you got to this position
 *    Node should derive from Tile, so you can call getValue()
 * U is a position, passed a pointer, something which derives from Tile (or a Tile)
 * The comparator is used by the priority_queue to put the element with the lowest total cost in front
 * since Nodes is a 1D vector representing a 2D grid, we need know the width of this grid
 * heurWeight is the heuristic weight paramters defined by the A* algorithm
 *
 * The function returns a list of moves (0 to 7) using following encoding. The central point is your current position
 *
 *         7 0 1
 *         6   2
 *         5 4 3
 */


template <typename T>
using Comparator = std::function<bool(const T&, const T&)>;

template <typename T>
using pq = std::priority_queue<T, std::vector<T>, Comparator<T>>;

template<typename U>
concept validPosType = requires(U * u)
{
  {u->getXPos()} -> std::same_as<int>;
  {u->getYPos()} -> std::same_as<int>;
};

template<typename T>
concept validNodeType = validPosType<T> && requires(T t)
{
  {T::f} -> std::same_as<float&>;
  {T::g} -> std::same_as<float&>;
  {T::h} -> std::same_as<float&>;
  {T::visited} -> std::same_as<bool&>;
  {T::prev} -> std::same_as<T*&>;
  {t.getValue()} -> std::same_as<float>;
};

template <validNodeType T, validPosType U>
std::vector<int> A_star(std::vector<T> & Nodes, const U * start, const U * destination, Comparator<T>& comp, unsigned int width, float heurWeight)
{
  QLoggingCategory pathfinderCategory("pathfinder", QtDebugMsg);
  pq<T> openList(comp);
  std::vector<int> path;
  T currentPathNode = Nodes.at(start->getYPos()*width+start->getXPos());
  T * parent = &(Nodes.at(start->getYPos()*width+start->getXPos()));
  Nodes.at(start->getYPos()*width+start->getXPos()).visited = true; // avoid to come here again
  while (currentPathNode.getXPos() != destination->getXPos()
         || currentPathNode.getYPos() != destination->getYPos())
  {
    int currentX = currentPathNode.getXPos();
    int currentY = currentPathNode.getYPos();
    qCDebug(pathfinderCategory) << "Node to continue... " << currentY << ", " << currentX;
    for (int deltaY = -1; deltaY <= 1; deltaY++)
      for (int deltaX = -1; deltaX <= 1; deltaX++){
        qCDebug(pathfinderCategory)<< "Checking : " << deltaX << ", " << deltaY;
        if (!(deltaX == 0 && deltaY == 0)){
          qCDebug(pathfinderCategory) << "Checking neighbour : " << deltaX << ", " << deltaY;
          checkNeighbour(Nodes, width, currentX+deltaX, currentY+deltaY, destination, parent, openList, heurWeight);
        }
      }
    if (openList.empty())
    {
      return std::vector<int>();
    }
    else
    {
      currentPathNode = openList.top();
      qCDebug(pathfinderCategory) << "currentPathNode from openlist: " << currentPathNode.getXPos() << ", " << currentPathNode.getYPos() << ", f: " << currentPathNode.h;
      qCDebug(pathfinderCategory) << "Node on top of openlist: " << openList.top().h;
      qCDebug(pathfinderCategory) << "Size of openlist: " << openList.size();
      parent = &(Nodes.at(currentPathNode.getYPos()*width+currentPathNode.getXPos()));
      openList.pop();
    }
  }
  //return list of path to reach destination
  T * dest = parent;
  //std::cout << "Getting list of moves to take." <<std::endl;
  while (dest->prev != nullptr)
  {
    int deltaX = dest->prev->getXPos() - dest->getXPos();
    int deltaY = dest->prev->getYPos() - dest->getYPos();
    int newMove = deltaX+10*deltaY;
    qCDebug(pathfinderCategory) << "X:" << deltaX << ", Y:" << deltaY;
    switch (newMove)
    {
      case -10: path.push_back(4); break;
      case -11: path.push_back(5); break;
      case -1: path.push_back(6); break;
      case 9: path.push_back(7); break;
      case 10: path.push_back(0); break;
      case 11: path.push_back(1); break;
      case 1: path.push_back(2); break;
      case -9: path.push_back(3); break;
      default: std::cerr << "wrong value for deltaX" << deltaX;
    }
    dest = dest->prev;
  }
  std::reverse(path.begin(), path.end());
  return path;
}


template <validNodeType T, typename U>
void checkNeighbour(std::vector<T> & Nodes, int width, int nX, int nY,  const U *destination, T* parent, pq<T> &openList, float heurWeight)
{
  QLoggingCategory pathfinderCategory("pathfinder", QtDebugMsg);
  int height = Nodes.size() / width;
  unsigned int currentX = parent->getXPos();
  unsigned int currentY = parent->getYPos();
  float currentCost = parent->f;
  if (nX >= 0 && nX < width && nY >= 0 && nY < height && (nX != 0 || nY != 0))
  {
    if (Nodes.at(nY*width+nX).getValue()!=std::numeric_limits<float>::infinity() ) //top
    {
      int manhDist = abs(static_cast<int>(destination->getXPos())-nX) + abs(static_cast<int>(destination->getYPos())-nY);
      float f = (std::fabs(Nodes.at(currentY*width+currentX).getValue() -
                           Nodes.at(nY*width+nX).getValue())) + 1.0f;
      qCDebug(pathfinderCategory) << "Manhattan distance from " << Nodes.at(currentY*width+currentX).getValue() << "x"
                                  <<   Nodes.at(nY*width+nX).getValue() << ";" << currentX << "x" << currentY << ";"
                                  << destination->getXPos() << "," << destination->getYPos() <<" to " << nX << "," << nY << " is " << manhDist
                                  << ", f is " << f;
      T & nextNode = Nodes.at(nY*width+nX);
      if (nextNode.visited == false)
      {
        //never been here
        //get distance to target
        nextNode.f = currentCost + f;
        nextNode.h = currentCost + f + heurWeight * manhDist;
        nextNode.prev = parent;
        nextNode.visited = true;
        qCDebug(pathfinderCategory)<< "Pushing in openlist... " << nX << ", " << nY << " currentCost:" << nextNode.h;
        openList.push(nextNode);
      }
      else
      {
        //check if current path is better than previous
        qCDebug(pathfinderCategory) << "Check if this path is better, currentCost:" << currentCost << ", f:" << f << ", nextnode.f:" << nextNode.f;
        if (currentCost + f + heurWeight * manhDist < (nextNode.h - 0.1f))
        {
          qCDebug(pathfinderCategory) << "This path is better, reparenting.";
          nextNode.f = currentCost + f;
          nextNode.h = currentCost + f + heurWeight * manhDist;
          nextNode.prev = parent;
          openList.push(nextNode);
        }
      }
    }
  }
  else
    qCDebug(pathfinderCategory) << "Not processing: " << nX << ", " << nY;
}
#endif // PATHFINDER_H

----- End of pathfinder_function.h -----

----- Start of world.cpp -----
#include "world.h"
#include <QDateTime>
#include <QImage>
#include <QRgb>
#include <QTimer>
#include <QtDebug>
#include <ctime>
#include <iostream>
#include <limits>
#include <random>
#include <sstream>

constexpr float maxEH{100.0f};

//class Tile
Tile::Tile(int xPosition, int yPosition, float tileWeight)
    : xPos{xPosition}, yPos{yPosition}, value{tileWeight}
{}

std::string Tile::serialize()
{
  std::stringstream res;
  res << xPos << "," << yPos << "," << value;
  return res.str();
}

//class Enemy
Enemy::Enemy(int xPosition, int yPosition, float strength)
    : Tile(xPosition, yPosition, strength)
{}

std::string Enemy::serialize()
{
  std::stringstream res;
  res << Tile::serialize() << "," << defeated;
  return res.str();
}

//class PEnemy
PEnemy::PEnemy(int xPosition, int yPosition, float strength)
    : Enemy(xPosition, yPosition, strength)
    , poisonLevel{strength}
{
  srand(time(nullptr));
}

bool PEnemy::poison()
{
  poisonLevel -= 10.0f;
  if (poisonLevel > 0.0f)
  {
    emit poisonLevelUpdated(poisonLevel);
    int t = rand() % 5;
    std::cout << "starting timer for " << t << " seconds"
              << " with poisonLevel = " << poisonLevel << std::endl;
    QTimer::singleShot(t * 1000, this, SLOT(poison()));
    return true;
  }
  else
  {
    poisonLevel = 0.0f;
    setDefeated(true);
    emit dead();
  }
  return false;
}

float PEnemy::getPoisonLevel() const
{
  return poisonLevel;
}

void PEnemy::setPoisonLevel(float value)
{
  poisonLevel = value;
}

std::string PEnemy::serialize()
{
  std::stringstream res;
  res << Enemy::serialize() << "," << poisonLevel;
  return res.str();
}

//class Protagonist
Protagonist::Protagonist()
    : Tile(0, 0, 0.0F)
    , health{maxEH}
    , energy{maxEH}
{}

std::string Protagonist::serialize()
{
  std::stringstream res;
  res << Tile::serialize() << "," << health << "," << energy;
  return res.str();
}

//class World
// methods throws a std::logic_error exception when file filename is not found
void World::createWorld(QString filename,
                        unsigned int nrOfEnemies,
                        unsigned int nrOfHealthpacks,
                        float pRatio)
{
  std::vector<bool> used;
  //read image in, every pixel greyvalue is value of tile, black pixels are considered as impassable, gets value infinity
  world.load(filename);
  if (world.isNull())
    throw std::logic_error(std::string("file " + filename.toStdString() + " not found"));
  rows = world.height();
  cols = world.width();
  tiles.reserve(rows * cols);
  used.reserve(rows * cols);
  for (int row = 0; row < rows; row++) {
    for (int col = 0; col < cols; col++) {
      float val = qGray(world.pixel(col, row)) / 255.0F;
      if (val > 0.0F)
        tiles.emplace_back(new Tile(col, row, val));
      else
        tiles.emplace_back(new Tile(col, row, std::numeric_limits<float>::infinity()));
    }
  }
  //generate enemies
  const unsigned int black{0xff000000};
  std::random_device r;

  // Choose a random distribution for x, y and strength
  std::default_random_engine e1(r());
  std::uniform_int_distribution<int> uniform_x(0, cols - 1);
  std::uniform_int_distribution<int> uniform_y(0, rows - 1);
  std::uniform_int_distribution<int> uniform_perc(0, 100);

  //use array used to check with positions are already occupied by E or HP
  enemies.reserve(nrOfEnemies);
  int PEnemyCounter = 0;
  while (enemies.size() < nrOfEnemies) {
    int xPos = uniform_x(e1);
    int yPos = uniform_y(e1);
    if (world.pixel(xPos, yPos) == black)
      continue;
    std::unique_ptr<Enemy> eptr;
    int dummy = static_cast<int>(1.0 / pRatio);
    if ((xPos + yPos) % dummy != 0)
    {
      eptr = std::make_unique<Enemy>(xPos, yPos, uniform_perc(e1));
    }
    else
    {
      eptr = std::make_unique<PEnemy>(xPos, yPos, uniform_perc(e1));
      PEnemyCounter++;
    }
    if (xPos != 0 || yPos != 0) {
      if (used[yPos * cols + xPos] == false)
      {
        enemies.push_back(std::move(eptr));
        used[yPos * cols + xPos] = true;
      }
    }
  }
  //be sure at least 1 PEnemy in the collection
  if (PEnemyCounter == 0 && nrOfEnemies > 0) {
    auto &en = enemies.at(nrOfEnemies - 1);
    int xPos = en->getXPos();
    int yPos = en->getYPos();
    float val = en->getValue();
    enemies.pop_back();
    auto eptr = std::make_unique<PEnemy>(xPos, yPos, val);
    enemies.push_back(std::move(eptr));
  }

  healthPacks.reserve(nrOfHealthpacks);
  while (healthPacks.size() < nrOfHealthpacks) {
    int xPos = uniform_x(e1);
    int yPos = uniform_y(e1);
    if (world.pixel(xPos, yPos) == black)
      continue;
    auto hptr = std::make_unique<Tile>(xPos, yPos, uniform_perc(e1));
    if (xPos != 0 || yPos != 0) {
      if (used[yPos * cols + xPos] == false) {
        healthPacks.push_back(std::move(hptr));
        used[yPos * cols + xPos] = true;
      }
    }
  }
}

std::vector<std::unique_ptr<Tile>> World::getTiles()
{
  if (world.isNull())
    throw "No tiles created yet";
  return std::move(tiles);
}

std::vector<std::unique_ptr<Enemy>> World::getEnemies()
{
  if (world.isNull())
    throw "No enemies created yet";
  return std::move(enemies);
}

std::vector<std::unique_ptr<Tile>> World::getHealthPacks()
{
  if (world.isNull())
    throw "No healthpacks created yet";
  return std::move(healthPacks);
}

std::unique_ptr<Protagonist> World::getProtagonist() const
{
  return std::make_unique<Protagonist>();
}

----- End of world.cpp -----

----- Start of world.h -----
#ifndef WORLD_H
#define WORLD_H

#include "world_global.h"
#include <vector>
#include <memory>
#include <QObject>
#include <QImage>
#include <exception>

class WORLDSHARED_EXPORT Tile
{
public:
    Tile(int xPosition, int yPosition, float tileWeight);
    virtual ~Tile() =default;
    float getValue() const {return value;};
    void setValue(float newValue) {value = newValue;};
    int getXPos() const {return xPos;};
    int getYPos() const {return yPos;};
    virtual void setXPos(int newPos) {xPos = newPos;};
    virtual void setYPos(int newPos) {yPos = newPos;};
    bool operator== (const Tile & other) const
        {return (getXPos() == other.getXPos()) && (getYPos() == other.getYPos());};
    virtual std::string serialize();

protected:
    int xPos;
    int yPos;
    float value;
};

class WORLDSHARED_EXPORT Enemy : public QObject, public Tile
{
    Q_OBJECT
public:
    Enemy(int xPosition, int yPosition, float strength);
    ~Enemy() override = default;
    bool getDefeated() const {return defeated;}
    void setDefeated(bool value) {defeated = value; if (defeated) emit dead();};
    std::string serialize() override;

  signals:
    void dead();

private:
    bool defeated {false};
};

class WORLDSHARED_EXPORT PEnemy: public Enemy
{
    Q_OBJECT
public:
    PEnemy(int xPosition, int yPosition, float strength);
    ~PEnemy() override = default;
    float getPoisonLevel() const;
    void setPoisonLevel(float value);
    std::string serialize() override;

public slots:
    bool poison();

signals:
    void poisonLevelUpdated(int value);

private:
    float poisonLevel;
};

class WORLDSHARED_EXPORT Protagonist: public QObject, public Tile
{
    Q_OBJECT
public:
    Protagonist();
    void setXPos(int newPos) override {if (xPos != newPos){xPos = newPos; emit posChanged(xPos, yPos);}}
    void setYPos(int newPos) override {if (yPos != newPos){yPos = newPos; emit posChanged(xPos, yPos);}}
    void setPos(int newX, int newY) {if (xPos != newX || yPos != newY) {xPos = newX; yPos = newY; emit posChanged(xPos, yPos);}}
    float getHealth() const {return health;};
    void setHealth(float value) {health = value; emit healthChanged(static_cast<int>(health));}

    float getEnergy() const {return energy;}
    void setEnergy(float value) {energy = value; emit energyChanged(static_cast<int>(energy));}
    std::string serialize() override;

signals:
    void posChanged(int x, int y);
    void healthChanged(int h);
    void energyChanged(int e);

private:
    float health {100.0f};
    float energy {100.0f};
};

class WORLDSHARED_EXPORT World
{
public:
    World() = default;
    //createWorld may throw a std::logic_error exception
    //pRatio is the percentage PEnemies of the total number of enemies
    void createWorld(QString filename, unsigned int nrOfEnemies, unsigned int nrOfHealthpacks, float pRatio = 0.25f);
    std::vector<std::unique_ptr<Tile>> getTiles();
    std::vector<std::unique_ptr<Enemy>> getEnemies();
    std::vector<std::unique_ptr<Tile>> getHealthPacks();
    std::unique_ptr<Protagonist> getProtagonist() const;
    int getRows() const {return rows;};
    int getCols() const {return cols;};

private:
    int rows, cols;
    QImage world;
    std::vector<std::unique_ptr<Tile>> tiles;
    std::vector<std::unique_ptr<Enemy>> enemies;
    std::vector<std::unique_ptr<Tile>> healthPacks;
};


#endif // WORLD_H

----- End of world.h -----

----- Start of world_global.h -----
#ifndef WORLD_GLOBAL_H
#define WORLD_GLOBAL_H

#include <QtCore/qglobal.h>

#if defined(WORLD_LIBRARY)
#  define WORLDSHARED_EXPORT Q_DECL_EXPORT
#else
#  define WORLDSHARED_EXPORT Q_DECL_IMPORT
#endif

#endif // WORLD_GLOBAL_H

----- End of world_global.h -----

----- Start of game.cpp -----
#include "game.h"
#include <algorithm> // for std::find_if
#include <cmath>
#include <random>

GameModel::GameModel(QString fileName, unsigned int nrOfEnemies, unsigned int nrOfHealthpacks, float pRatio, float hp)
    : background{new QPixmap(fileName)}
{
    World *world = new World();
    world->createWorld(fileName, nrOfEnemies, nrOfHealthpacks, pRatio);
    tiles = world->getTiles();
    // enemies = world->getEnemies();
    protag = std::make_unique<ProtagonistModel>();
    rows = world->getRows();
    cols = world->getCols();

    // Random number generator
    std::default_random_engine generator;
    std::uniform_real_distribution<float> distribution(0.0, 1.0);

    // HealthPacks from Tile to HealthPack
    //  Convert the vector to a vector of unique pointers to the derived class

    for (auto &basePtr : world->getHealthPacks())
    {
        // Use std::move to transfer ownership to the new vector
        std::unique_ptr<HealthPack> hpPtr = std::make_unique<HealthPack>(basePtr->getXPos(), basePtr->getYPos(), hp);
        healthPacks.emplace_back(std::move(hpPtr));
    }
    // PEnemys & XEnemys from Enemy to PEnemyModel & XEnemy
    // Define the proportion of enemies to be transformed into XEnemies
    const float proportionOfXEnemies = 0.20f; // 20% of enemies are XEnemies

    for (auto &enemy : world->getEnemies())
    {
        if (dynamic_cast<PEnemy *>(enemy.get()))
        {
            std::unique_ptr<PEnemyModel> pePtr = std::make_unique<PEnemyModel>(enemy->getXPos(), enemy->getYPos(), enemy->getValue());
            enemies.emplace_back(std::move(pePtr));
        }
        else
        {
            // Randomly decide whether to transform this enemy into an XEnemy
            if (distribution(generator) < proportionOfXEnemies)
            {
                std::unique_ptr<XEnemy> xePtr = std::make_unique<XEnemy>(enemy->getXPos(), enemy->getYPos(), enemy->getValue());
                enemies.emplace_back(std::move(xePtr));
            }
            else
            {
                std::unique_ptr<Enemy> regularEnemyPtr = std::make_unique<Enemy>(enemy->getXPos(), enemy->getYPos(), enemy->getValue());
                enemies.emplace_back(std::move(regularEnemyPtr));
            }
        }
    }

    //generate 2 Gates, levelup*1, leveldown*1
    gates.emplace_back(std::make_unique<Gate>(0,0,false));
    //generate gate in unique position
    std::vector<bool> used(cols*rows);
    //mark all used pos
    for(auto& e: enemies)
    {
        used[e->getYPos() * cols + e->getXPos()] = true;
    }
    for(auto& hp: healthPacks)
    {
        used[hp->getYPos() * cols + hp->getXPos()] = true;
    }
    std::random_device r;
    std::default_random_engine e1(r());
    std::uniform_int_distribution<int> uniform_x(0, cols - 1);
    std::uniform_int_distribution<int> uniform_y(0, rows - 1);
    bool isUnique = false;
    while (!isUnique) {
        int xPos = uniform_x(e1);
        int yPos = uniform_y(e1);
        if (background->toImage().pixelColor(xPos, yPos) == QColor(Qt::black))
            continue;
        auto gatePtr = std::make_unique<Gate>(xPos,yPos,true);
        if (xPos != 0 || yPos != 0) {
            if (used[yPos * cols + xPos] == false) {
                gates.push_back(std::move(gatePtr));
                used[yPos * cols + xPos] = true;
                isUnique = true;
            }
        }
    }
}

bool GameModel::isWall(int x, int y)
{
    for (auto &t : tiles)
    {
        if (t->getXPos() == x && t->getYPos() == y)
        {
            if (t->getValue() == std::numeric_limits<float>::infinity())
            {
                return true;
            }
            return false;
        }
    }
    return false;
}

std::vector<std::unique_ptr<Tile>>::iterator GameModel::findTile(int x, int y)
{
    auto it = std::find_if(tiles.begin(), tiles.end(),
                           [x, y](const auto &t)
                           {
                               return t->getXPos() == x && t->getYPos() == y;
                           });

    return it;
}

std::vector<std::unique_ptr<Enemy>>::iterator GameModel::findEnemy(int x, int y)
{
    auto it = std::find_if(enemies.begin(), enemies.end(),
                           [x, y](const auto &e)
                           {
                               return e->getXPos() == x && e->getYPos() == y;
                           });

    return it;
}

std::vector<std::unique_ptr<HealthPack>>::iterator GameModel::findHealthPack(int x, int y)
{
    auto it = std::find_if(healthPacks.begin(), healthPacks.end(),
                           [x, y](const auto &h)
                           {
                               return h->getXPos() == x && h->getYPos() == y;
                           });

    return it;
}

std::vector<std::unique_ptr<Gate>>::iterator GameModel::findGate(int x, int y)
{
    auto it = std::find_if(gates.begin(), gates.end(),
                           [x, y](const auto& g)
                           {
                               return g->getXPos() == x && g->getYPos() == y;
                           });

    return it;
}

float GameModel::findPoison(int x, int y)
{
    float poisonLevel = 0.0f;

    for (auto &e : enemies)
    {
        PEnemyModel *pEnemy = dynamic_cast<PEnemyModel *>(e.get());
        if (pEnemy)
        {
            // Calculate the distance between the protagonist and the center of the poison
            int distX = std::abs(x - pEnemy->getXPos());
            int distY = std::abs(y - pEnemy->getYPos());
            int range = pEnemy->getPoisonRange();
            float level = pEnemy->getPoisonLevel();
            // Check if the protagonist is within the poison
            if (distX <= (range - 1) && distY <= (range - 1))
            {
                if (level > poisonLevel)
                {
                    poisonLevel = level;
                }
            }
        }
    }

    return poisonLevel;
}

----- End of game.cpp -----

----- Start of game.h -----
#ifndef GAME_H
#define GAME_H

#include <QGraphicsScene>
#include "models/healthpack.h"
#include "models/penemy.h"
#include "models/xenemy.h"
#include "models/protagonist.h"
#include "models/gate.h"
class GameModel
{
public:
    GameModel(QString fileName, unsigned int nrOfEnemies, unsigned int nrOfHealthpacks, float pRatio = 0.25f, float hp = 100.0f);
    const std::vector<std::unique_ptr<Tile>> &getTiles() const { return tiles; };
    const std::vector<std::unique_ptr<Enemy>> &getEnemies() const { return enemies; };
    const std::vector<std::unique_ptr<HealthPack>> &getHealthPacks() const { return healthPacks; };
    const std::unique_ptr<ProtagonistModel> &getProtagonist() const { return protag; };
    const std::vector<std::unique_ptr<Gate>> & getGates() const {return gates;};
    int getRows() const { return rows; };
    int getCols() const { return cols; };
    QPixmap *getBackground() { return background; };

    bool isWall(int x, int y);
    std::vector<std::unique_ptr<Tile>>::iterator findTile(int x, int y);
    std::vector<std::unique_ptr<Enemy>>::iterator findEnemy(int x, int y);
    std::vector<std::unique_ptr<HealthPack>>::iterator findHealthPack(int x, int y);
    std::vector<std::unique_ptr<Gate>>::iterator findGate(int x,int y);
    float findPoison(int x, int y); // return the poisonLevel at this position

private:
    int rows, cols;
    QPixmap *background;
    std::unique_ptr<ProtagonistModel> protag;
    std::vector<std::unique_ptr<Tile>> tiles;
    std::vector<std::unique_ptr<Enemy>> enemies;
    std::vector<std::unique_ptr<HealthPack>> healthPacks;
    std::vector<std::unique_ptr<Gate>> gates;
};

#endif // GAME_H

----- End of game.h -----

----- Start of gate.cpp -----
#include "gate.h"

Gate::Gate(int xPosition, int yPosition, bool gateType, float strength)
    : Tile(xPosition, yPosition, strength), gateType{gateType}
{}

bool Gate::getType() const
{
    return gateType;
}

void Gate::updateLevel()
{
    if(gateType)
    {
        emit levelUp();
    }else
    {
        emit levelDown();
    }
}

----- End of gate.cpp -----

----- Start of gate.h -----
#ifndef GATE_H
#define GATE_H

#include <QObject>
#include "lib/world.h"

class Gate : public QObject, public Tile
{
    Q_OBJECT
public:
    Gate(int xPosition, int yPosition, bool gateType, float strength = 0.0f);
    bool getType() const;
    void updateLevel();

private:
    bool gateType; //0: return to previous level; 1: next level
public slots:

signals:
    void levelUp();
    void levelDown();

};

#endif // GATE_H

----- End of gate.h -----

----- Start of healthpack.h -----
#ifndef HEALTHPACK_H
#define HEALTHPACK_H

#include <sstream>
#include "lib/world.h"

class HealthPack : public QObject, public Tile
{
    Q_OBJECT
public:
    // Constructor for the HealthPack class
    HealthPack(int xPosition, int yPosition, float strength = 30.0f)
        : Tile(xPosition, yPosition, strength),
          hp{strength} {};

    // Destructor for the HealthPack class
    ~HealthPack() override = default;

    // Get the health points of the health pack
    float getHP() const { return hp; }

    // Set the health points of the health pack and emit a signal if HP is <= 0
    void setHP(float hp)
    {
        this->hp = hp;
        if (hp <= 0.0f)
            emit hpPicked();
    }

    // Serialize the HealthPack object to a string
    std::string serialize() override;

private:
    float hp{0.0f}; // Health points of the health pack

signals:
    void hpPicked(); // Signal emitted when the health pack is picked up

public slots:
};

#endif // HEALTHPACK_H

// Implementation of the serialize function
inline std::string HealthPack::serialize()
{
    std::stringstream res;
    res << Tile::serialize() << "," << hp;
    return res.str();
}

----- End of healthpack.h -----

----- Start of penemy.cpp -----
#include "penemy.h"

PEnemyModel::PEnemyModel(int xPosition, int yPosition, float strength)
    : PEnemy(xPosition, yPosition, strength)
{
}

int PEnemyModel::getPoisonRange() const
{
    return poisonRange;
}

void PEnemyModel::addPoisonRange(int value)
{
    poisonRange += value;
    emit poisonUpdated(getPoisonRange(), getPoisonLevel());
}

void PEnemyModel::setPoisonRange(int newPoisonRange)
{
    poisonRange = newPoisonRange;
}

----- End of penemy.cpp -----

----- Start of penemy.h -----
#ifndef PENEMYMODEL_H
#define PENEMYMODEL_H

#include <QObject>
#include "lib/world.h"

class PEnemyModel : public PEnemy
{
    Q_OBJECT

public:
    PEnemyModel(int xPosition, int yPosition, float strength);

    int getPoisonRange() const;
    void addPoisonRange(int value);

    void setPoisonRange(int newPoisonRange);

private:
    int poisonRange{1};

signals:
    void poisonUpdated(int range, float poisonLevel);
};

#endif // PENEMYMODEL_H

----- End of penemy.h -----

----- Start of protagonist.cpp -----
#include "protagonist.h"

ProtagonistModel::ProtagonistModel()
    : Protagonist()
{
}

bool ProtagonistModel::getIsPoisoned() const
{
    return isPoisoned;
}

void ProtagonistModel::setIsPoisoned(bool newIsPoisoned)
{
    isPoisoned = newIsPoisoned;

    if (newIsPoisoned)
    {
        emit protagPoisoned();
    }
    else
    {
        emit protagRecovered();
    }
}

----- End of protagonist.cpp -----

----- Start of protagonist.h -----
#ifndef PROTAGONISTMODEL_H
#define PROTAGONISTMODEL_H

#include <QObject>
#include "lib/world.h"

class ProtagonistModel : public Protagonist
{
    Q_OBJECT
public:
    ProtagonistModel();
    bool getIsPoisoned() const;
    void setIsPoisoned(bool newIsPoisoned);

private:
    bool isPoisoned{false};

public slots:
signals:
    void protagPoisoned();
    void protagRecovered();
};

#endif // PROTAGONISTMODEL_H

----- End of protagonist.h -----

----- Start of tileadapter.h -----
#ifndef TILEADAPTER_H
#define TILEADAPTER_H
#include <iostream>
#include "lib/world.h"

class TileAdapter
{
public:
    Tile *tile; // Reference to the actual Tile
    float f, g, h;
    bool visited;
    TileAdapter *prev;

    TileAdapter(Tile *t) : tile(t), f(0.0f), g(0.0f), h(0.0f), visited(false), prev(nullptr) {}

    // Delegate methods to the Tile
    int getXPos() const { return tile->getXPos(); }
    int getYPos() const { return tile->getYPos(); }
    float getValue() const { return tile->getValue(); }
};

#endif // TILEADAPTER_H

----- End of tileadapter.h -----

----- Start of xenemy.cpp -----
#include "xenemy.h"

XEnemy::XEnemy(int xPosition, int yPosition, float strength) : Enemy(xPosition, yPosition, strength)
{
}

void XEnemy::setBounceTimes(int value)
{
    bounceTimes = value;
}

int XEnemy::getBounceTimes() const
{
    return bounceTimes;
}

std::string XEnemy::serialize()
{
    std::stringstream res;
    res << Enemy::serialize() << "," << bounceTimes;
    return res.str();
}

bool XEnemy::bounceProtagonist()
{
    bounceTimes++;
    if (bounceTimes < 3)
    {
        emit bounce();
        return true;
    }
    else
    {
        setDefeated(true);
        emit dead();
    }
    return false;
}
----- End of xenemy.cpp -----

----- Start of xenemy.h -----
#ifndef XENEMYMODEL_H
#define XENEMYMODEL_H

#include <QObject>
#include <QtDebug>
#include <iostream>
#include <sstream>
#include "lib/world.h"

class XEnemy : public Enemy
{
    Q_OBJECT

public:
    XEnemy(int xPosition, int yPosition, float strength);
    ~XEnemy() override = default;
    std::string serialize() override;
    void setBounceTimes(int value);
    int getBounceTimes() const;

private:
    int bounceTimes{0};

signals:
    void bounce();

public slots:
    bool bounceProtagonist();
};

#endif // XENEMYMODEL_H
----- End of xenemy.h -----

----- Start of game_over.h -----
#ifndef GAME_OVER_H
#define GAME_OVER_H

#include <QDialog>
#include <QPushButton>
#include <QLabel>
#include <QVBoxLayout>
#include <QDebug>

class GameOverDialog : public QDialog
{
    Q_OBJECT

public:
    explicit GameOverDialog(QWidget *parent = nullptr) : QDialog(parent)
    {
        setWindowTitle("Game Over");
        QVBoxLayout *layout = new QVBoxLayout(this);

        QLabel *label = new QLabel("Game Over!", this);
        label->setAlignment(Qt::AlignCenter);
        layout->addWidget(label);

        QPushButton *restartButton = new QPushButton("Restart", this);
        layout->addWidget(restartButton);
        setMinimumWidth(300);

        connect(restartButton, &QPushButton::clicked, this, &GameOverDialog::onRestartClicked);
        // connect(restartButton, &QPushButton::clicked, this, &GameOverDialog::close);
    }

signals:
    void restartGame();

private slots:
    void onRestartClicked()
    {
        this->deleteLater();
        this->close();
        emit restartGame();
    }
};

#endif // GAME_OVER_H

----- End of game_over.h -----

----- Start of graphic.cpp -----
#include "graphic.h"

View2D::View2D(GameModel *model, int size, int bgSkin) : size(size)
{
    // Initialize the scene and add it to the view
    scene = new QGraphicsScene();
    this->setScene(scene);

    const std::vector<std::unique_ptr<Tile>> &tiles = model->getTiles();
    const std::unique_ptr<ProtagonistModel> &protag = model->getProtagonist();
    const std::vector<std::unique_ptr<Enemy>> &enemies = model->getEnemies();
    const std::vector<std::unique_ptr<HealthPack>> &hps = model->getHealthPacks();

    // Set the default size of the view.
    this->setFixedSize(size * model->getCols() + 2, size * model->getRows() + 2);

    // Construct views according to the tile model and connect

    // Construct a background view for the model and connect
    if (bgSkin == 1)
    {
        new GrassworldView2D(tiles, size, scene);
    }
    else
    {
        new GrassworldView2D(tiles, size, scene);
    }

    // Construct controllers for the model and connect
    ProtagonistView2D *pView = new ProtagonistView2D(size, protag->getXPos(), protag->getYPos());
    scene->addItem(pView);
    connect(protag.get(), SIGNAL(posChanged(int, int)), pView, SLOT(handlePosChanged(int, int)));
    connect(protag.get(), SIGNAL(protagPoisoned()), pView, SLOT(handlePoioned()));
    connect(protag.get(), SIGNAL(protagRecovered()), pView, SLOT(handleRecovered()));

    for (const auto &e : enemies)
    {
        // Generate the views of tiles according to the tile type
        if (dynamic_cast<PEnemyModel *>(e.get()))
        {
            PEnemyView2D *pView = new PEnemyView2D(size, e->getXPos(), e->getYPos(), model->getCols(), model->getRows());
            scene->addItem(pView);
            scene->addItem(pView->getPoisons());
            // pView->drawPoison(model->getCols(),model->getRows());
            connect(e.get(), SIGNAL(dead()), pView, SLOT(handleDead()));
            connect(e.get(), SIGNAL(poisonUpdated(int, float)), pView, SLOT(handlePoisonUpdated(int, float)));
        }
        else if (dynamic_cast<XEnemy *>(e.get()))
        {
            XEnemyView2D *xView = new XEnemyView2D(size, e->getXPos(), e->getYPos());
            scene->addItem(xView);
            connect(e.get(), SIGNAL(dead()), xView, SLOT(handleDead()));
        }
        else
        {
            EnemyView2D *eView = new EnemyView2D(size, e->getXPos(), e->getYPos());
            scene->addItem(eView);
            connect(e.get(), SIGNAL(dead()), eView, SLOT(handleDead()));
        }
    }
    for (const auto &h : hps)
    {
        HealthPackView2D *hView = new HealthPackView2D(size, h->getXPos(), h->getYPos());
        scene->addItem(hView);
        connect(h.get(), SIGNAL(hpPicked()), hView, SLOT(handlePicked()));
    }
    for (const auto &g : model->getGates())
    {
        GateView2D *gView = new GateView2D(size, g->getXPos(), g->getYPos());
        scene->addItem(gView);
    }
}

QGraphicsScene *View2D::getScene() const
{
    return scene;
}

void View2D::mousePressEvent(QMouseEvent *event)
{
    int x = event->x() / size; // Convert mouse coordinates to tile coordinates
    int y = event->y() / size;
    qDebug() << "Emitting coordinates x and y: " << x << " " << y;
    emit tileClicked(x, y); // Emit the signal
    QGraphicsView::mousePressEvent(event);
}

int View2D::getTileSize() const
{
    return size;
}

void View2D::keyPressEvent(QKeyEvent *event)
{
    // Emit a signal with key information
    emit keyPressed(event->key());
}

void View2D::wheelEvent(QWheelEvent *event)
{
    // Zoom
    const ViewportAnchor anchor = transformationAnchor();
    setTransformationAnchor(QGraphicsView::AnchorUnderMouse);
    int angle = event->angleDelta().y();
    qreal factor;
    if (angle > 0 && zoomFactor <= 5.0f)
    {
        factor = 1.03;
    }
    else if (angle < 0)
    {
        factor = 0.97;
        if (zoomFactor * factor < 1.0f)
        {
            factor = 1.0f / zoomFactor;
        }
    }
    else
    {
        return;
    }
    zoomFactor *= factor;
    scale(factor, factor);
    setTransformationAnchor(anchor);
}

void View2D::cleanupMarkedTiles(){
    QList<QGraphicsItem*> itemsToRemove;

    for (QGraphicsItem* item : scene->items()) {
            // Check if the item is a MarkedTileView2D
            MarkedTileView2D* markedTile = dynamic_cast<MarkedTileView2D*>(item);
            if (markedTile) {
                // Add to the list for removal
                itemsToRemove.append(item);
            }
        }

        // Remove and delete the marked tiles
        for (QGraphicsItem* item : itemsToRemove) {
            scene->removeItem(item);
            delete item;
        }

}

void View2D::markVisited(int x, int y)
{
    QPair<int, int> tilePos(x, y);

    // Check if this tile is already marked
    if (!markedTiles.contains(tilePos))
    {
        // Create a new marked tile view
        MarkedTileView2D *markedView = new MarkedTileView2D(size, x, y);
        scene->addItem(markedView); // Assuming 'scene' is your QGraphicsScene instance

        // Store the reference to the marked tile
        markedTiles.insert(tilePos, markedView);
    }

    // Optional: Add any additional logic for already marked tiles
}

----- End of graphic.cpp -----

----- Start of graphic.h -----
#ifndef GRAPHIC_H
#define GRAPHIC_H

#include <QObject>
#include <QLabel>
#include <QPushButton>
#include <QGraphicsView>
#include <QGraphicsScene>
#include <QKeyEvent>
#include <QWheelEvent>
#include <QTimeLine>
#include <QMap>
#include <QPair>

#include "lib/world.h"
#include "models/game.h"
#include "graphic_markedtile.h"
#include "views/graphic_protagonist.h"
#include "views/graphic_healthpack.h"
#include "views/graphic_gate.h"
#include "views/graphic_penemy.h"
#include "views/graphic_xenemy.h"
#include "views/graphic_background_grassworld.h"
#include "controllers/protagonist_control.h"

// Define a class called View2D that inherits from QGraphicsView
class View2D : public QGraphicsView
{
    Q_OBJECT

public:
    // Constructor for the View2D class, takes a GameModel pointer and an integer size as parameters
    View2D(GameModel *model, int size, int bgSkin=1 );
    QGraphicsScene *scene; // Pointer to the QGraphicsScene
    virtual ~View2D(){};   // Virtual destructor

    // Zoom in or out by changing the size of tiles
    int getTileSize() const;
    void markVisited(int x, int y);
    void cleanupMarkedTiles();

    QGraphicsScene *getScene() const;

private:
    int size{1};                                           // Size of tiles
    float zoomFactor{1.0f};                                // Zoom factor
    QMap<QPair<int, int>, MarkedTileView2D *> markedTiles; // Map to store marked tile instances
    // Override keyPressEvent to handle key events
    void keyPressEvent(QKeyEvent *event) override;
    void mousePressEvent(QMouseEvent *event) override;
    // Override wheelEvent to handle wheel events
    void wheelEvent(QWheelEvent *event) override;

signals:
    void keyPressed(int key); // Signal emitted when a key is pressed
    void tileClicked(int x, int y);
public slots:
};

#endif // GRAPHIC_H

----- End of graphic.h -----

----- Start of graphic_background_brick.h -----
#ifndef GRAPHIC_BACKGROUND_BRICK_H
#define GRAPHIC_BACKGROUND_BRICK_H

#include <QObject>
#include <QImage>
#include "views/graphic_tile.h"

class BrickView2D : public TileView2D
{
    Q_OBJECT

public:
    BrickView2D(int size, int xPos, int yPos)
        : TileView2D(size, xPos, yPos)
    {
        QPixmap resizedPixmap = (new QPixmap(QString(":/src/tile_images/brick.png")))->scaled(size, size);
        this->setPixmap(resizedPixmap);
        this->setZValue(1);
    };

private:
public slots:
};

#endif // GRAPHIC_BACKGROUND_BRICK_H

----- End of graphic_background_brick.h -----

----- Start of graphic_background_grassbrick.h -----
#ifndef GRAPHIC_BACKGROUND_GRASSBRICK_H
#define GRAPHIC_BACKGROUND_GRASSBRICK_H

#include <QObject>
#include <QImage>
#include "views/graphic_tile.h"

class GrassbrickView2D : public TileView2D
{
    Q_OBJECT

public:
    GrassbrickView2D(int size, int xPos, int yPos)
        : TileView2D(size, xPos, yPos)
    {
        QPixmap resizedPixmap = (new QPixmap(QString(":/src/tile_images/grassbrick.png")))->scaled(size, size);
        this->setPixmap(resizedPixmap);
        this->setZValue(1);
    };

private:
public slots:
};

#endif // GRAPHIC_BACKGROUND_GRASSBRICK_H

----- End of graphic_background_grassbrick.h -----

----- Start of graphic_background_grassflower.h -----
#ifndef GRAPHIC_BACKGROUND_GRASSFLOWER_H
#define GRAPHIC_BACKGROUND_GRASSFLOWER_H

#include <QObject>
#include <QImage>
#include "views/graphic_tile.h"

class GrassflowerView2D : public TileView2D
{
    Q_OBJECT

public:
    GrassflowerView2D(int size, int xPos, int yPos)
        : TileView2D(size, xPos, yPos)
    {
        QPixmap resizedPixmap = (new QPixmap(QString(":/src/tile_images/grassflower.png")))->scaled(size, size);
        this->setPixmap(resizedPixmap);
        this->setZValue(1);
    };

private:
public slots:
};

#endif // GRAPHIC_BACKGROUND_GRASSFLOWER_H

----- End of graphic_background_grassflower.h -----

----- Start of graphic_background_grassworld.h -----
#ifndef GRAPHIC_BACKGROUND_GRASSWORLD_H
#define GRAPHIC_BACKGROUND_GRASSWORLD_H

#include "models/game.h"
#include "graphic_background_grassbrick.h"
#include "graphic_background_grassflower.h"
#include "graphic_background_lightgrass.h"
#include "graphic_background_brick.h"
#include "graphic_background_yellowgrass.h"
#include "graphic_background_pool.h"
#include "graphic_background_road.h"
#include "graphic_background_greengrass.h"

class GrassworldView2D
{

public:
    GrassworldView2D(const std::vector<std::unique_ptr<Tile>> &tiles, int size, QGraphicsScene *scene)
        : size(size)
    {
        for (const auto &t : tiles)
        {
            if (t->getValue() == std::numeric_limits<float>::infinity())
            {
                BrickView2D *brickView = new BrickView2D(size, t->getXPos(), t->getYPos());
                scene->addItem(brickView);
            }
            else if (t->getValue() > 0.65f)
            {
                RoadView2D *roadView = new RoadView2D(size, t->getXPos(), t->getYPos());
                scene->addItem(roadView);
            }
            else if (t->getValue() > 0.6f)
            {
                GrassflowerView2D *grassflowerView = new GrassflowerView2D(size, t->getXPos(), t->getYPos());
                scene->addItem(grassflowerView);
            }
            else if (t->getValue() > 0.3f)
            {
                YellowgrassView2D *yellowgrassView = new YellowgrassView2D(size, t->getXPos(), t->getYPos());
                scene->addItem(yellowgrassView);
            }
            else if (t->getValue() > 0.2f)
            {
                GreengrassView2D *greengrassView = new GreengrassView2D(size, t->getXPos(), t->getYPos());
                scene->addItem(greengrassView);
            }
            else if (t->getValue() > 0.12f)
            {
                LightgrassView2D *lightgrassView = new LightgrassView2D(size, t->getXPos(), t->getYPos());
                scene->addItem(lightgrassView);
            }
            else
            {
                PoolView2D *poolView = new PoolView2D(size, t->getXPos(), t->getYPos());
                scene->addItem(poolView);
            }
        }
    };
    ~GrassworldView2D(){};

private:
    int size;
public slots:
};

#endif // GRAPHIC_BACKGROUND_GRASSWORLD_H

----- End of graphic_background_grassworld.h -----

----- Start of graphic_background_greengrass.h -----
#ifndef GRAPHIC_BACKGROUND_GREENGRASS_H
#define GRAPHIC_BACKGROUND_GREENGRASS_H

#include <QObject>
#include <QImage>
#include "views/graphic_tile.h"

class GreengrassView2D : public TileView2D
{
    Q_OBJECT

public:
    GreengrassView2D(int size, int xPos, int yPos)
        : TileView2D(size, xPos, yPos)
    {
        QPixmap resizedPixmap = (new QPixmap(QString(":/src/tile_images/greengrass.png")))->scaled(size, size);
        this->setPixmap(resizedPixmap);
        this->setZValue(1);
    };

private:
public slots:
};

#endif // GRAPHIC_BACKGROUND_GREENGRASS_H

----- End of graphic_background_greengrass.h -----

----- Start of graphic_background_lightgrass.h -----
#ifndef GRAPHIC_BACKGROUND_LIGHTGRASS_H
#define GRAPHIC_BACKGROUND_LIGHTGRASS_H

#include <QObject>
#include <QImage>
#include "views/graphic_tile.h"

class LightgrassView2D : public TileView2D
{
    Q_OBJECT

public:
    LightgrassView2D(int size, int xPos, int yPos)
        : TileView2D(size, xPos, yPos)
    {
        QPixmap resizedPixmap = (new QPixmap(QString(":/src/tile_images/lightgrass.png")))->scaled(size, size);
        this->setPixmap(resizedPixmap);
        this->setZValue(1);
    };

private:
public slots:
};

#endif // GRAPHIC_BACKGROUND_LIGHTGRASS_H

----- End of graphic_background_lightgrass.h -----

----- Start of graphic_background_pool.h -----
#ifndef GRAPHIC_BACKGROUND_POOL_H
#define GRAPHIC_BACKGROUND_POOL_H

#include <QObject>
#include <QImage>
#include "views/graphic_tile.h"

class PoolView2D : public TileView2D
{
    Q_OBJECT

public:
    PoolView2D(int size, int xPos, int yPos)
        : TileView2D(size, xPos, yPos)
    {
        QPixmap resizedPixmap = (new QPixmap(QString(":/src/tile_images/pool.png")))->scaled(size, size);
        this->setPixmap(resizedPixmap);
        this->setZValue(1);
    };

private:
public slots:
};

#endif // GRAPHIC_BACKGROUND_POOL_H

----- End of graphic_background_pool.h -----

----- Start of graphic_background_road.h -----
#ifndef GRAPHIC_BACKGROUND_ROAD_H
#define GRAPHIC_BACKGROUND_ROAD_H

#include <QObject>
#include <QImage>
#include "views/graphic_tile.h"

class RoadView2D : public TileView2D
{
    Q_OBJECT

public:
    RoadView2D(int size, int xPos, int yPos)
        : TileView2D(size, xPos, yPos)
    {
        QPixmap resizedPixmap = (new QPixmap(QString(":/src/tile_images/road.png")))->scaled(size, size);
        this->setPixmap(resizedPixmap);
        this->setZValue(1);
    };

private:
public slots:
};

#endif // GRAPHIC_BACKGROUND_ROAD_H

----- End of graphic_background_road.h -----

----- Start of graphic_background_yellowgrass.h -----
#ifndef GRAPHIC_BACKGROUND_YELLOWGRASS_H
#define GRAPHIC_BACKGROUND_YELLOWGRASS_H

#include <QObject>
#include <QImage>
#include "views/graphic_tile.h"

class YellowgrassView2D : public TileView2D
{
    Q_OBJECT

public:
    YellowgrassView2D(int size, int xPos, int yPos)
        : TileView2D(size, xPos, yPos)
    {
        QPixmap resizedPixmap = (new QPixmap(QString(":/src/tile_images/yellowgrass.png")))->scaled(size, size);
        this->setPixmap(resizedPixmap);
        this->setZValue(1);
    };

private:
public slots:
};

#endif // GRAPHIC_BACKGROUND_YELLOWGRASS_H

----- End of graphic_background_yellowgrass.h -----

----- Start of graphic_enemy.h -----
#ifndef GRAPHIC_ENEMY_H
#define GRAPHIC_ENEMY_H

#include <QObject>
#include <QImage>
#include "views/graphic_tile.h"

class EnemyView2D : public TileView2D
{
    Q_OBJECT

public:
    // Constructor for the EnemyView2D class
    EnemyView2D(int size, int xPos, int yPos) : TileView2D(size, xPos, yPos)
    {
        this->viewAlive = new QPixmap(QString(":/src/tile_images/enemy.png"));
        this->viewDead = new QPixmap(QString(":/src/tile_images/enemy_dead.png"));
        this->setPixmap(viewAlive->scaled(size, size));
        this->setZValue(2);
    };

    // Destructor for the EnemyView2D class
    ~EnemyView2D()
    {
        delete viewAlive;
        delete viewDead;
    };

protected:
    bool dead{false};   // Flag to track if the enemy is dead
    QPixmap *viewAlive; // Pixmap for the alive enemy view
    QPixmap *viewDead;  // Pixmap for the dead enemy view

public slots:
    // Handle the event when the enemy is defeated
    inline void handleDead()
    {
        dead = true;
        this->setPixmap(viewDead->scaled(size, size));
    }
};

#endif // GRAPHIC_ENEMY_H

----- End of graphic_enemy.h -----

----- Start of graphic_gate.h -----
#ifndef GRAPHIC_GATE_H
#define GRAPHIC_GATE_H

#include <QImage>
#include "views/graphic_tile.h"

class GateView2D : public TileView2D
{

public:
    // Constructor for the HealthPackView2D class
    GateView2D(int size, int xPos, int yPos)
        : TileView2D(size, xPos, yPos)
    {
        // Set the pixmap and Z-value for the health pack view
        QPixmap resizedPixmap = (new QPixmap(QString(":/src/tile_images/gate.png")))->scaled(size, size);
        this->setPixmap(resizedPixmap);
        this->setZValue(2); // Set the Z-value for layering
    };

private:

};

#endif // GRAPHIC_GATE_H

----- End of graphic_gate.h -----

----- Start of graphic_healthpack.h -----
#ifndef GRAPHIC_HEALTHPACK_H
#define GRAPHIC_HEALTHPACK_H

#include <QObject>
#include <QImage>
#include "views/graphic_tile.h"

class HealthPackView2D : public TileView2D
{
    Q_OBJECT

public:
    // Constructor for the HealthPackView2D class
    HealthPackView2D(int size, int xPos, int yPos)
        : TileView2D(size, xPos, yPos)
    {
        // Set the pixmap and Z-value for the health pack view
        QPixmap resizedPixmap = (new QPixmap(QString(":/src/tile_images/heal.png")))->scaled(size, size);
        this->setPixmap(resizedPixmap);
        this->setZValue(2); // Set the Z-value for layering
    };

private:
public slots:
    // Handle the event when the health pack is picked up
    void handlePicked();
};

// Implementation of the handlePicked slot
inline void HealthPackView2D::handlePicked()
{
    this->deleteLater(); // Delete the health pack view after it's picked up
}

#endif // GRAPHIC_HEALTHPACK_H

----- End of graphic_healthpack.h -----

----- Start of graphic_markedtile.h -----
#ifndef GRAPHIC_MARKEDTILE_H
#define GRAPHIC_MARKEDTILE_H

#include <QObject>
#include <QGraphicsItem>
#include <QGraphicsScale>
#include "views/graphic_tile.h"

class MarkedTileView2D : public TileView2D
{
    Q_OBJECT

public:
    MarkedTileView2D(int size, int xPos, int yPos, QObject *parent = nullptr)
        : TileView2D(size, xPos, yPos)
    {
        this->setParent(parent);
        this->setPixmap(QPixmap(":/src/tile_images/marked.png").scaled(size, size)); // Path to the marked tile image
        this->setZValue(4);                                                          // Ensure it's rendered above the base tile

        // Initialize the scale transformation
        scaleTransform = new QGraphicsScale(this);
        // Set the origin to the center for scaling
        QPointF originPoint(this->pixmap().width() / 2, this->pixmap().height() / 2);
        scaleTransform->setOrigin(QVector3D(originPoint.x(), originPoint.y(), 0));

        this->setTransformations(QList<QGraphicsTransform *>() << scaleTransform);
    }

    QGraphicsScale *getScaleTransform() const;

private:
    QGraphicsScale *scaleTransform;
};

#endif // GRAPHIC_MARKEDTILE_H

----- End of graphic_markedtile.h -----

----- Start of graphic_penemy.cpp -----
#include "graphic_penemy.h"

PEnemyView2D::PEnemyView2D(int size, int xPos, int yPos, int cols, int rows)
    : EnemyView2D(size, xPos, yPos), viewPoison(new QPixmap(":/src/tile_images/poison.png")), cols(cols), rows(rows)
{
    this->viewAlive = new QPixmap(QString(":/src/tile_images/p_alive.png"));
    this->viewDead = new QPixmap(QString(":/src/tile_images/p_dead.png"));

    this->setPixmap(viewAlive->scaled(size, size));
    this->setZValue(3);
    poisons = new QGraphicsItemGroup();
    poisons->setZValue(2);
    // poisons->setPos(xPos*size,yPos*size);
}

int min(int a, int b)
{
    return a < b ? a : b;
}

int max(int a, int b)
{
    return a > b ? a : b;
}

void PEnemyView2D::handlePoisonUpdated(int range, float poisonLevel)
{
    // timer(animation) start or keep
    // poison color change according to value

    // poison range change according to value
    clearPoisons();
    // paint poison pixmap and store in one pixmap

    int xStart = max(0, xPos - range / 2);
    int xEnd = min(cols - 1, xPos + range / 2);
    int yStart = max(0, yPos - range / 2);
    int yEnd = min(rows - 1, yPos + range / 2);
    int height = viewPoison->height(); // Height of the original pixmap
    int widthToCopy = height;          // Width of the frame you want to select
    // Create a new pixmap to hold the concatenated images
    for (int k = 0; k < 4; k++)
    {
        QPixmap *pTempPix = new QPixmap((xEnd - xStart + 1) * height, (yEnd - yStart + 1) * height); // Set width and height as needed
        // Create a QPainter to paint on the concatenated pixmap
        QPainter painter(pTempPix);

        for (int i = xStart; i <= xEnd; i++)
        {
            for (int j = yStart; j <= yEnd; j++)
            {
                // if(i != xPos || j != yPos)
                // {
                //     painter.drawPixmap((i-xStart)*height, (j-yStart)*height,widthToCopy,widthToCopy,viewPoison->copy(k*widthToCopy, 0, height, height));
                // }
                painter.drawPixmap((i - xStart) * height, (j - yStart) * height, widthToCopy, widthToCopy, viewPoison->copy(k * widthToCopy, 0, height, height));
            }
        }

        // End painting
        painter.end();
        QGraphicsPixmapItem *pTempItem = new QGraphicsPixmapItem();
        pTempItem->setPixmap(pTempPix->scaled((xEnd - xStart + 1) * size, (yEnd - yStart + 1) * size));

        // Create opacity effect
        QGraphicsOpacityEffect *opacityEffect = new QGraphicsOpacityEffect;
        pTempItem->setGraphicsEffect(opacityEffect);

        // Set the initial opacity to 0 (completely transparent)
        // opacityEffect->setOpacity(1);

        // Create opacity animation
        QPropertyAnimation *opacityAnimation = new QPropertyAnimation(opacityEffect, "opacity");
        opacityAnimation->setDuration(1000);                           // Set the duration of the animation in milliseconds
        opacityAnimation->setStartValue(poisonLevel / 100.0f);         // Start with full transparency
        opacityAnimation->setEndValue((poisonLevel - 10.0f) / 100.0f); // End with full opacity

        // Start the opacity animation
        opacityAnimation->start();

        // Set the position and add the item to the group
        pTempItem->setPos((xStart)*size, (yStart)*size);
        pTempItem->setVisible(true);
        poisons->addToGroup(pTempItem);
    }
}

QGraphicsItemGroup *PEnemyView2D::getPoisons() const
{
    return poisons;
}

void PEnemyView2D::clearPoisons()
{
    if (poisons)
    {
        QList<QGraphicsItem *> itemsInGroup = poisons->childItems();

        for (QGraphicsItem *item : itemsInGroup)
        {
            // Remove the item from the group
            poisons->removeFromGroup(item);
            // Optionally, delete the item if it's no longer needed
            delete item;
        }

        // Additionally, you can clear the entire group from the scene
        // poisons->scene()->removeItem(poisons);
    }
}

----- End of graphic_penemy.cpp -----

----- Start of graphic_penemy.h -----
#ifndef GRAPHIC_PENEMY_H
#define GRAPHIC_PENEMY_H

#include <QObject>
#include <QImage>
#include <QPainter>
#include <QGraphicsPixmapItem>
#include <QGraphicsOpacityEffect>
#include <QPropertyAnimation>
#include "views/graphic_enemy.h"

class PEnemyView2D : public EnemyView2D
{
    Q_OBJECT

public:
    PEnemyView2D(int size, int xPos, int yPos, int cols, int rows);

    QGraphicsItemGroup *getPoisons() const;
    void clearPoisons();

private:
    QPixmap *viewPoison;
    QGraphicsItemGroup *poisons;
    int poisonIndex{0};
    float poisonOpacity{1.0f};
    int cols;
    int rows;

public slots:
    void handlePoisonUpdated(int range, float poisonLevel);
};

#endif // GRAPHIC_PENEMY_H

----- End of graphic_penemy.h -----

----- Start of graphic_poison.h -----
#ifndef GRAPHIC_POISON_H
#define GRAPHIC_POISON_H

#include <QObject>
#include <QGraphicsItem>
#include <QGraphicsScale>
#include "views/graphic_tile.h"

class PoisonView2D : public TileView2D
{
    Q_OBJECT

public:
    PoisonView2D(int size, int xPos, int yPos, QObject *parent = nullptr)
        : TileView2D(size, xPos, yPos)
    {
        this->setParent(parent);
        this->setPixmap(QPixmap(":/src/tile_images/poisoned.png").scaled(size, size));
        this->setZValue(4);

        // Initialize the scale transformation
        scaleTransform = new QGraphicsScale(this);
        // Set the origin to the bottom-left corner
        QPointF originPoint(0, this->pixmap().height());
        scaleTransform->setOrigin(QVector3D(originPoint.x(), originPoint.y(), 0));

        this->setTransformations(QList<QGraphicsTransform *>() << scaleTransform);
    }

    QGraphicsScale *getScaleTransform() const;

private:
    QGraphicsScale *scaleTransform;
};

inline QGraphicsScale *PoisonView2D::getScaleTransform() const
{
    return scaleTransform;
}

#endif // GRAPHIC_POISON_H

----- End of graphic_poison.h -----

----- Start of graphic_protagonist.cpp -----
#include "graphic_protagonist.h"

ProtagonistView2D::ProtagonistView2D(int size, int xPos, int yPos)
    : TileView2D(size, xPos, yPos),
      viewAlive(new QPixmap(QString(":/src/tile_images/player1.png")))
{
    // Set up the protagonist view
    this->setPixmap(viewAlive->scaled(size, size));
    this->setZValue(5);

    // Create the poisoned view
    viewPoisoned = new PoisonView2D(size, 0, 0, this);
    viewPoisoned->setPos(0, -1 * size);

    // Initialize poisoned animation for xScale
    poisonedAnimationX = new QPropertyAnimation(viewPoisoned->getScaleTransform(), "xScale", viewPoisoned);
    poisonedAnimationX->setDuration(1000);
    poisonedAnimationX->setKeyValueAt(0, 1.2);   // Starting scale
    poisonedAnimationX->setKeyValueAt(0.5, 1.8); // Midpoint - maximum scale
    poisonedAnimationX->setKeyValueAt(1, 1.2);   // End - back to original scale
    poisonedAnimationX->setEasingCurve(QEasingCurve::InOutQuad);
    poisonedAnimationX->setLoopCount(-1);

    // Initialize poisoned animation for yScale
    poisonedAnimationY = new QPropertyAnimation(viewPoisoned->getScaleTransform(), "yScale", viewPoisoned);
    poisonedAnimationY->setDuration(1000);
    poisonedAnimationY->setKeyValueAt(0, 1.2);   // Starting scale
    poisonedAnimationY->setKeyValueAt(0.5, 1.8); // Midpoint - maximum scale
    poisonedAnimationY->setKeyValueAt(1, 1.2);   // End - back to original scale
    poisonedAnimationY->setEasingCurve(QEasingCurve::InOutQuad);
    poisonedAnimationY->setLoopCount(-1);
}

void ProtagonistView2D::handlePosChanged(int x, int y)
{
    this->setPos(x * size, y * size);
}

void ProtagonistView2D::handlePoioned()
{
    viewPoisoned->setParentItem(this);
    viewPoisoned->setVisible(true);
    // Start the animations
    poisonedAnimationX->start();
    poisonedAnimationY->start();
}

void ProtagonistView2D::handleRecovered()
{
    // Stop the animations
    poisonedAnimationX->stop();
    poisonedAnimationY->stop();
    viewPoisoned->setVisible(false);
    viewPoisoned->setParentItem(nullptr);
}

----- End of graphic_protagonist.cpp -----

----- Start of graphic_protagonist.h -----
#ifndef GRAPHIC_PROTAGONIST_H
#define GRAPHIC_PROTAGONIST_H

#include <QPropertyAnimation>
#include <QImage>
#include "views/graphic_tile.h"
#include "views/graphic_poison.h"

class ProtagonistView2D : public TileView2D
{
    Q_OBJECT

public:
    // Constructor for the ProtagonistView2D class
    ProtagonistView2D(int size, int xPos, int yPos);

    // Destructor for the ProtagonistView2D class
    ~ProtagonistView2D() { delete viewAlive; };

private:
    bool dead{false};   // Flag to track if the protagonist is dead
    QPixmap *viewAlive; // Pixmap for the alive protagonist view
    PoisonView2D *viewPoisoned;
    QPropertyAnimation *poisonedAnimationX;
    QPropertyAnimation *poisonedAnimationY;

public slots:
    // Handle position changes for the protagonist
    void handlePosChanged(int x, int y);
    void handlePoioned();
    void handleRecovered();
};

#endif // GRAPHIC_PROTAGONIST_H

----- End of graphic_protagonist.h -----

----- Start of graphic_tile.h -----
#ifndef GRAPHIC_TILE_H
#define GRAPHIC_TILE_H

#include <QGraphicsPixmapItem>

class TileView2D : public QObject, public QGraphicsPixmapItem
{
    Q_OBJECT

public:
    // Constructor for the TileView2D class
    TileView2D(int size, int xPos, int yPos)
        : size(size),
          xPos(xPos),
          yPos(yPos)
    {
        // Set the position offset based on the tile size and coordinates
        this->setPos(xPos * size, yPos * size);
    };

protected:
    int size{1}; // Size of the tile
    int xPos{0}; // X position of the tile
    int yPos{0}; // Y position of the tile
};

#endif // GRAPHIC_TILE_H

----- End of graphic_tile.h -----

----- Start of graphic_xenemy.h -----
#ifndef GRAPHIC_XENEMY_H
#define GRAPHIC_XENEMY_H

#include <QObject>
#include <QImage>
#include "views/graphic_enemy.h"

class XEnemyView2D : public EnemyView2D
{
    Q_OBJECT

public:
    XEnemyView2D(int size, int xPos, int yPos)
        : EnemyView2D(size, xPos, yPos)
    {
        this->viewAlive = new QPixmap(QString(":/src/tile_images/x_alive.png"));
        this->viewDead = new QPixmap(QString(":/src/tile_images/x_dead.png"));
        this->setPixmap(viewAlive->scaled(size, size));
        this->setZValue(2);
    };

private:
};
#endif // GRAPHIC_XENEMY_H

----- End of graphic_xenemy.h -----

----- Start of text.cpp -----
#include "text.h"

ViewText::ViewText(GameModel *model, int size) : size(size)
{
    // Initialize the scene and add it to the view
    scene = new QGraphicsScene();
    this->setScene(scene);

    const std::vector<std::unique_ptr<Tile>> &tiles = model->getTiles();
    const std::unique_ptr<ProtagonistModel> &protag = model->getProtagonist();
    const std::vector<std::unique_ptr<Enemy>> &enemies = model->getEnemies();
    const std::vector<std::unique_ptr<HealthPack>> &hps = model->getHealthPacks();

    // Set the default size of the view.
    this->setFixedSize(size * model->getCols() + 2, size * model->getRows() + 2);

    // Construct a background view for the model and connect
    new GrassworldViewText(tiles, size, scene);

    ProtagonistViewText *ptView = new ProtagonistViewText(size, protag->getXPos(), protag->getYPos());
    scene->addItem(ptView);
    connect(protag.get(), SIGNAL(posChanged(int, int)), ptView, SLOT(handlePosChanged(int, int)));

    for (const auto &e : enemies)
    {
        // Generate the views of tiles according to the tile type
        if (dynamic_cast<PEnemy *>(e.get()))
        {
            PEnemyViewText *pView = new PEnemyViewText(size, e->getXPos(), e->getYPos());
            scene->addItem(pView);
            connect(e.get(), SIGNAL(dead()), pView, SLOT(handleDead()));
            connect(e.get(), SIGNAL(poisonLevelUpdated(int)), pView, SLOT(handlePoisonLevelUpdated(int)));
        }
        else if (dynamic_cast<XEnemy *>(e.get()))
        {
            XEnemyViewText *xView = new XEnemyViewText(size, e->getXPos(), e->getYPos());
            scene->addItem(xView);
            connect(e.get(), SIGNAL(dead()), xView, SLOT(handleDead()));
        }
        else
        {
            EnemyViewText *eView = new EnemyViewText(size, e->getXPos(), e->getYPos());
            scene->addItem(eView);
            connect(e.get(), SIGNAL(dead()), eView, SLOT(handleDead()));
        }
    }

    for (const auto &h : hps)
    {
        HealthPackViewText *hView = new HealthPackViewText(size, h->getXPos(), h->getYPos());
        scene->addItem(hView);
        connect(h.get(), SIGNAL(hpPicked()), hView, SLOT(handlePicked()));
    }

    for (const auto &g : model->getGates())
    {
        QGraphicsTextItem *gateViewText;
        gateViewText = new QGraphicsTextItem(QString("O"));
        gateViewText->setPos(g->getXPos() * size, g->getYPos() * size);

        // Set text color to black
        gateViewText->setDefaultTextColor(Qt::black);

        // Set text bold
        QFont font = gateViewText->font();
        font.setBold(true);
        gateViewText->setFont(font);

        scene->addItem(gateViewText);
    }
}

void ViewText::wheelEvent(QWheelEvent *event)
{
    // Set the transformation anchor to the position of the mouse cursor.
    const ViewportAnchor anchor = transformationAnchor();
    setTransformationAnchor(QGraphicsView::AnchorUnderMouse);

    // Get the amount of scrolling from the wheel event, specifically in the vertical direction.
    int angle = event->angleDelta().y();

    // This will hold the factor by which we'll scale the view.
    qreal factor;

    // Check if the wheel was scrolled upwards and the current zoom factor is not greater than 5.0.
    if (angle > 0 && zoomFactor <= 5.0f)
    {
        // If so, increase the zoom factor slightly (zoom in).
        factor = 1.03;
    }
    // Check if the wheel was scrolled downwards.
    else if (angle < 0)
    {
        // Decrease the zoom factor slightly (zoom out).
        factor = 0.97;

        // If the new zoom factor would be less than 1.0, adjust it so the zoom doesn't go below 1.0.
        if (zoomFactor * factor < 1.0f)
        {
            factor = 1.0f / zoomFactor;
        }
    }
    else
    {
        // If there's no vertical scroll, exit the function.
        return;
    }

    // Update the zoom factor.
    zoomFactor *= factor;

    // Apply the scaling to the view.
    scale(factor, factor);

    // Restore the original transformation anchor.
    setTransformationAnchor(anchor);
}

void ViewText::cleanupMarkedTiles()
{
    QList<QGraphicsItem *> itemsToRemove;

    for (QGraphicsItem *item : scene->items())
    {
        // Check if the item is a MarkedTileView2D
        TextMarkedTile *markedTile = dynamic_cast<TextMarkedTile *>(item);
        if (markedTile)
        {
            // Add to the list for removal
            itemsToRemove.append(item);
        }
    }

    // Remove and delete the marked tiles
    for (QGraphicsItem *item : itemsToRemove)
    {
        scene->removeItem(item);
        delete item;
    }
}

void ViewText::markVisited(int x, int y)
{
    QPair<int, int> tilePos(x, y);

    // Check if this tile is already marked
    if (!markedTiles.contains(tilePos))
    {
        // Create a new TextMarkedTile object
        TextMarkedTile *markedView = new TextMarkedTile(size, x, y);
        scene->addItem(markedView); // Assuming 'scene' is your QGraphicsScene instance

        // Store the reference to the marked tile
        markedTiles.insert(tilePos, markedView);
    }
}

----- End of text.cpp -----

----- Start of text.h -----
#ifndef TEXDT_H
#define TEXDT_H

#include <QObject>
#include <QLabel>
#include <QPushButton>
#include <QGraphicsView>
#include <QGraphicsScene>

#include <QKeyEvent>
#include <QWheelEvent>
#include <QTimeLine>

#include "lib/world.h"
#include "models/game.h"
#include "views/text_protagonist.h"
#include "views/text_healthpack.h"
#include "views/text_penemy.h"
#include "views/text_xenemy.h"
#include "views/text_background.h"
#include "controllers/protagonist_control.h"
#include "text_markedtile.h"

// Define a class called ViewText that inherits from QGraphicsView
class ViewText : public QGraphicsView
{
    Q_OBJECT

public:
    // Constructor for the ViewText class, takes a GameModel pointer and an integer size as parameters
    ViewText(GameModel *model, int size);

    QGraphicsScene *scene; // Pointer to the QGraphicsScene
    virtual ~ViewText(){}; // Virtual destructor

    // Zoom in or out by changing the size of tiles
    void zoom(int newSize);
    void markVisited(int x, int y);
    void cleanupMarkedTiles();

private:
    int size{1};                                         // Size of tiles
    float zoomFactor{1.0f};                              // Zoom factor
    QMap<QPair<int, int>, TextMarkedTile *> markedTiles; // Map to store marked tile instances

    // Override wheelEvent to handle wheel events
    void wheelEvent(QWheelEvent *event) override;

public slots:
};

#endif // TEXDT_H

----- End of text.h -----

----- Start of text_background.h -----
#ifndef TEXT_BACKGROUND_H
#define TEXT_BACKGROUND_H

#include "models/game.h"

class GrassworldViewText
{

public:
    GrassworldViewText(const std::vector<std::unique_ptr<Tile>> &tiles, int size, QGraphicsScene *scene)
        : size(size)
    {
        for (const auto &t : tiles)
        {
            QGraphicsTextItem *tileView;
            if (t->getValue() == std::numeric_limits<float>::infinity())
            {
                tileView = new QGraphicsTextItem(QString("|"));
                tileView->setPos(t->getXPos() * size, t->getYPos() * size);
                tileView->setDefaultTextColor(Qt::gray);
            }
            else if (t->getValue() > 0.6f)
            {
                tileView = new QGraphicsTextItem(QString("."));
                tileView->setPos(t->getXPos() * size, t->getYPos() * size);
                tileView->setDefaultTextColor(Qt::yellow);
            }
            else if (t->getValue() > 0.3f)
            {
                tileView = new QGraphicsTextItem(QString("."));
                tileView->setPos(t->getXPos() * size, t->getYPos() * size);
                tileView->setDefaultTextColor(Qt::green);
            }
            else if (t->getValue() > 0.2f)
            {
                tileView = new QGraphicsTextItem(QString("_"));
                tileView->setPos(t->getXPos() * size, t->getYPos() * size);
                tileView->setDefaultTextColor(Qt::darkGreen);
            }
            else if (t->getValue() > 0.12f)
            {
                tileView = new QGraphicsTextItem(QString("_"));
                tileView->setPos(t->getXPos() * size, t->getYPos() * size);
                tileView->setDefaultTextColor(Qt::blue);
            }
            else
            {
                tileView = new QGraphicsTextItem(QString("_"));
                tileView->setPos(t->getXPos() * size, t->getYPos() * size);
                tileView->setDefaultTextColor(Qt::cyan);
            }
            scene->addItem(tileView);
        }
    };

private:
    int size;
public slots:
};

#endif // TEXT_BACKGROUND_H

----- End of text_background.h -----

----- Start of text_enemy.h -----
#ifndef TEXT_ENEMY_H
#define TEXT_ENEMY_H

#include <QObject>
#include "views/text_tile.h"

class EnemyViewText : public TileViewText
{
    Q_OBJECT

public:
    // Constructor for the EnemyViewText class
    EnemyViewText(int size, int xPos, int yPos) : TileViewText(size, xPos, yPos)
    {
        this->setPlainText(QString("E"));
        this->setZValue(2);
    };

    // Set the status of the enemy (alive or dead)
    void setIsDead(bool newIsDead);

public slots:
    // Handle the event when the enemy is defeated
    inline void handleDead()
    {
        dead = true;
        this->setPlainText(QString(" "));
    };

protected:
    bool dead{false}; // Flag to track if the enemy is dead
};

#endif // TEXT_ENEMY_H

----- End of text_enemy.h -----

----- Start of text_healthpack.h -----
#ifndef TEXT_HEALTHPACK_H
#define TEXT_HEALTHPACK_H

#include "views/text_tile.h"
#include <QFont> // Include for QFont

class HealthPackViewText : public TileViewText
{
    Q_OBJECT

public:
    // Constructor for the HealthPackViewText class
    HealthPackViewText(int size, int xPos, int yPos)
        : TileViewText(size, xPos, yPos)
    {
        // Set the pixmap and Z-value for the health pack view
        this->setPlainText(QString("+"));
        QFont font = this->font();
        font.setBold(true);
        this->setFont(font);
        this->setPos(xPos * size, yPos * size);
        this->setZValue(2); // Set the Z-value for layering
    };

private:
public slots:
    // Handle the event when the health pack is picked up
    void handlePicked();
};

// Implementation of the handlePicked slot
inline void HealthPackViewText::handlePicked()
{
    this->deleteLater(); // Delete the health pack view after it's picked up
}

#endif // TEXT_HEALTHPACK_H

----- End of text_healthpack.h -----

----- Start of text_markedtile.h -----
#ifndef TEXT_MARKEDTILE_H
#define TEXT_MARKEDTILE_H

#include "text_tile.h" // Include the header file for TileViewText
#include <QFont>
#include <QBrush>

class TextMarkedTile : public TileViewText
{
public:
    TextMarkedTile(int size, int xPos, int yPos)
        : TileViewText(size, xPos, yPos) // Call the constructor of the base class
    {
        setPlainText("X");                        // Set the text to 'X'
        setDefaultTextColor(Qt::red);             // Set the color to red
        setFont(QFont("Arial", 10, QFont::Bold)); // Set the font

        // The position is already set by the TileViewText constructor
    }
};

#endif // TEXT_MARKEDTILE_H

----- End of text_markedtile.h -----

----- Start of text_penemy.cpp -----
#include "text_penemy.h"

PEnemyViewText::PEnemyViewText(int size, int xPos, int yPos, int cols, int rows)
    : EnemyView2D(size, xPos, yPos), viewPoison(new ), cols(cols), rows(rows)
{
    this->viewAlive = new QPixmap(QString(":/src/tile_images/p_alive.png"));
    this->viewDead = new QPixmap(QString(":/src/tile_images/p_dead.png"));

    this->setPixmap(viewAlive->scaled(size, size));
    this->setZValue(3);
    poisons = new QGraphicsItemGroup();
    poisons->setZValue(2);
    // poisons->setPos(xPos*size,yPos*size);
}

int min(int a, int b)
{
    return a < b ? a : b;
}

int max(int a, int b)
{
    return a > b ? a : b;
}

void  PEnemyViewText::handlePoisonUpdated(int range, float poisonLevel)
{
    // timer(animation) start or keep
    // poison color change according to value

    // poison range change according to value
    clearPoisons();
    // paint poison pixmap and store in one pixmap

    int xStart = max(0, xPos - range / 2);
    int xEnd = min(cols - 1, xPos + range / 2);
    int yStart = max(0, yPos - range / 2);
    int yEnd = min(rows - 1, yPos + range / 2);
    int height = viewPoison->height(); // Height of the original pixmap
    int widthToCopy = height;          // Width of the frame you want to select
    // Create a new pixmap to hold the concatenated images
    for (int k = 0; k < 4; k++)
    {
        QPixmap *pTempPix = new QPixmap((xEnd - xStart + 1) * height, (yEnd - yStart + 1) * height); // Set width and height as needed
        // Create a QPainter to paint on the concatenated pixmap
        QPainter painter(pTempPix);

        for (int i = xStart; i <= xEnd; i++)
        {
            for (int j = yStart; j <= yEnd; j++)
            {
                // if(i != xPos || j != yPos)
                // {
                //     painter.drawPixmap((i-xStart)*height, (j-yStart)*height,widthToCopy,widthToCopy,viewPoison->copy(k*widthToCopy, 0, height, height));
                // }
                painter.drawPixmap((i - xStart) * height, (j - yStart) * height, widthToCopy, widthToCopy, viewPoison->copy(k * widthToCopy, 0, height, height));
            }
        }

        // End painting
        painter.end();
        QGraphicsPixmapItem *pTempItem = new QGraphicsPixmapItem();
        pTempItem->setPixmap(pTempPix->scaled((xEnd - xStart + 1) * size, (yEnd - yStart + 1) * size));

        // Create opacity effect
        QGraphicsOpacityEffect *opacityEffect = new QGraphicsOpacityEffect;
        pTempItem->setGraphicsEffect(opacityEffect);

        // Set the initial opacity to 0 (completely transparent)
        // opacityEffect->setOpacity(1);

        // Create opacity animation
        QPropertyAnimation *opacityAnimation = new QPropertyAnimation(opacityEffect, "opacity");
        opacityAnimation->setDuration(1000);                           // Set the duration of the animation in milliseconds
        opacityAnimation->setStartValue(poisonLevel / 100.0f);         // Start with full transparency
        opacityAnimation->setEndValue((poisonLevel - 10.0f) / 100.0f); // End with full opacity

        // Start the opacity animation
        opacityAnimation->start();

        // Set the position and add the item to the group
        pTempItem->setPos((xStart)*size, (yStart)*size);
        pTempItem->setVisible(true);
        poisons->addToGroup(pTempItem);
    }
}

QGraphicsItemGroup * PEnemyViewText::getPoisons() const
{
    return poisons;
}

void  PEnemyViewText::clearPoisons()
{
    if (poisons)
    {
        QList<QGraphicsItem *> itemsInGroup = poisons->childItems();

        for (QGraphicsItem *item : itemsInGroup)
        {
            // Remove the item from the group
            poisons->removeFromGroup(item);
            // Optionally, delete the item if it's no longer needed
            delete item;
        }

        // Additionally, you can clear the entire group from the scene
        // poisons->scene()->removeItem(poisons);
    }
}

----- End of text_penemy.cpp -----

----- Start of text_penemy.h -----
#ifndef TEXT_PENEMY_H
#define TEXT_PENEMY_H

#include <QObject>
#include <QImage>
#include "views/text_enemy.h"

class PEnemyViewText : public EnemyViewText
{
    Q_OBJECT

public:
    PEnemyViewText(int size, int xPos, int yPos)
        : EnemyViewText(size, xPos, yPos)
    {
        this->setPlainText(QString("P"));
        this->setZValue(2);
    };

private:
    QGraphicsTextItem *viewPoison;
    int poisonIndex{0};
    int poisonRange{3};

public slots:
    inline void handlePoisonLevelUpdated(int value){};
};

#endif // TEXT_PENEMY_H

----- End of text_penemy.h -----

----- Start of text_poison.h -----
#ifndef TEXT_POISON_H
#define TEXT_POISON_H
#include <QObject>
#include <QGraphicsItem>
#include <QGraphicsScale>
#include "views/text_tile.h"

class TextPoison : public TileViewText
{
    Q_OBJECT

public:
    TextPoison(int size, int xPos, int yPos, QObject *parent = nullptr)
        : TileViewText(size, xPos, yPos)
    {
        this->setParent(parent);
        this->setPlainText(QString("X_X"));  // 'P' for poison
        this->setZValue(4);

        // Initialize the scale transformation
        scaleTransform = new QGraphicsScale(this);
        // Set the origin to the bottom-left corner
        QPointF originPoint(0, 0);
        scaleTransform->setOrigin(QVector3D(originPoint.x(), originPoint.y(), 0));

        this->setTransformations(QList<QGraphicsTransform *>() << scaleTransform);
    }

    QGraphicsScale *getScaleTransform() const;

private:
    QGraphicsScale *scaleTransform;
};

inline QGraphicsScale *TextPoison::getScaleTransform() const
{
    return scaleTransform;
}

#endif // TEXT_POISON_H


----- End of text_poison.h -----

----- Start of text_protagonist.h -----
#ifndef TEXT_PROTAGONIST_H
#define TEXT_PROTAGONIST_H

#include "views/text_tile.h"

class ProtagonistViewText : public TileViewText
{
    Q_OBJECT

public:
    // Constructor for the ProtagonistViewText class
    ProtagonistViewText(int size, int xPos, int yPos)
        : TileViewText(size, xPos, yPos)
    {
        this->setPlainText(QString("@")); // Set the pixmap for the protagonist view
        this->setPos(xPos * size, yPos * size);
    };

private:
    bool dead{false}; // Flag to track if the protagonist is dead

public slots:
    // Handle position changes for the protagonist
    void handlePosChanged(int x, int y)
    {
        this->setPos(x * size, y * size);
    }
};

#endif // TEXT_PROTAGONIST_H

----- End of text_protagonist.h -----

----- Start of text_tile.h -----
#ifndef TEXT_TILE_H
#define TEXT_TILE_H

#include <QObject>
#include <QGraphicsTextItem>

class TileViewText : public QGraphicsTextItem
{
    Q_OBJECT

public:
    // Constructor for the TileViewText class
    TileViewText(int size, int xPos, int yPos)
        : size(size),
          xPos(xPos),
          yPos(yPos)
    {
        // Set the position offset based on the tile size and coordinates
        this->setPos(xPos * size, yPos * size);
    };

protected:
    int size{1}; // Size of the tile
    int xPos{0}; // X position of the tile
    int yPos{0}; // Y position of the tile
};

#endif // TEXT_TILE_H

----- End of text_tile.h -----

----- Start of text_xenemy.h -----
#ifndef TEXT_XENEMY_H
#define TEXT_XENEMY_H

#include <QObject>
#include <QImage>
#include "views/text_enemy.h"

class XEnemyViewText : public EnemyViewText
{
    Q_OBJECT

public:
    XEnemyViewText(int size, int xPos, int yPos)
        : EnemyViewText(size, xPos, yPos)
    {
        this->setPlainText(QString("B"));
        this->setZValue(2);
    };

private:
};
#endif // TEXT_XENEMY_H

----- End of text_xenemy.h -----

